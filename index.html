<HTML><HEAD>
<TITLE>ps2tek - Documentation on PS2 internals</title>
</HEAD><BODY bgcolor="#FFFFFF" text="#000000" link="#0033cc" vlink="#0033cc" alink="#0033cc">
  <TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="contents"></A>&nbsp;
  Contents
</FONT></TD></TR></TABLE><BR>
  <A HREF="#memorymap">Memory Map</A><BR>
  <A HREF="#iomaps">I/O Maps</A><BR>
  <A HREF="#gif">Graphics Interface (GIF)</A><BR>
  <A HREF="#dmac">DMA Controller (DMAC)</A><BR>
  <A HREF="#gs">Graphics Synthesizer (GS)</A><BR>
  <A HREF="#vu">Vector Unit (VU)</A><BR>
  <A HREF="#eeintc">EE Interrupt Controller (INTC)</A><BR>
  <A HREF="#cdvd">CDVD Drive</A><BR>
  <A HREF="#iopint">IOP Interrupts</A><BR>
  <A HREF="#ioptimers">IOP Timers</A><BR>
  <A HREF="#bios">BIOS</A><BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="memorymap"></A>&nbsp;
Memory Map
</FONT></TD></TR></TABLE><BR>
<B>EE Virtual/Physical Memory Map</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  KUSEG: 00000000h-7FFFFFFFh User segment
  KSEG0: 80000000h-9FFFFFFFh Kernel segment 0
  KSEG1: A0000000h-BFFFFFFFh Kernel segment 1
  
  Virtual    Physical
  00000000h  00000000h  32 MB    Main RAM (first 1 MB reserved for kernel)
  20000000h  00000000h  32 MB    Main RAM, uncached
  30100000h  00100000h  31 MB    Main RAM, uncached and accelerated
  10000000h  10000000h  64 KB    I/O registers
  11000000h  11000000h  4 KB     VU0 code memory
  11004000h  11004000h  4 KB     VU0 data memory
  11008000h  11008000h  16 KB    VU1 code memory
  1100C000h  1100C000h  16 KB    VU1 data memory
  12000000h  12000000h  8 KB     GS privileged registers
  1C000000h  1C000000h  2 MB     IOP RAM
  1FC00000h  1FC00000h  4 MB     BIOS, uncached (rom0)
  9FC00000h  1FC00000h  4 MB     BIOS, cached (rom09)
  BFC00000h  1FC00000h  4 MB     BIOS, uncached (rom0b)
  70000000h  ---------  16 KB    Scratchpad RAM (only accessible via virtual addressing)
</TD></TR></TABLE>
EE RAM is reportedly expandable up to 256 MB.
However, the maximum seen in practice is 128 MB, for special TOOL consoles.<BR>
<BR>
<B>IOP Physical Memory Map</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  KUSEG: 00000000h-7FFFFFFFh User segment
  KSEG0: 80000000h-9FFFFFFFh Kernel segment 0
  KSEG1: A0000000h-BFFFFFFFh Kernel segment 1
  
  Physical
  00000000h  2 MB     Main RAM (same as on PSX)
  1D000000h           SIF registers
  1F800000h  64 KB    Various I/O registers
  1F900000h  1 KB     SPU2 registers
  1FC00000h  4 MB     BIOS (rom0) - Same as EE BIOS
  
  FFFE0000h (KSEG2)   Cache control
</TD></TR></TABLE><BR>
<B>Additional Memory</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4 MB   GS VRAM (used for framebuffer, textures, zbuffer, etc)
  2 MB   SPU2 work RAM - quadrupled from PSX's SPU
  8 MB   Memory card
</TD></TR></TABLE><BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="iomaps"></A>&nbsp;
I/O Maps
</FONT></TD></TR></TABLE><BR>
  
EE Map<BR>
<B>EE Timers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  100000xxh        Timer 0
  100008xxh        Timer 1
  100010xxh        Timer 2
  100018xxh        Timer 3
</TD></TR></TABLE>
<B>Image Processing Unit (IPU)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  10002000h 8h     IPU Command
  10002010h 4h     IPU Control
  10002020h 4h     IPU bit pointer control
  10002030h 8h     Top of bitstream
  10007000h 10h    Out FIFO (read)
  10007010h 10h    In FIFO (write)
</TD></TR></TABLE>
<B>Graphics Interface (GIF)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  10003000h 4h     GIF_CTRL - Control register
  10003010h 4h     GIF_MODE - Mode setting
  10003020h 4h     GIF_STAT - Status
  10003040h 4h     GIF_TAG0 - Bits 0-31 of tag before
  10003050h 4h     GIF_TAG1 - Bits 32-63 of tag before
  10003060h 4h     GIF_TAG2 - Bits 64-95 of tag before
  10003070h 4h     GIF_TAG3 - Bits 96-127 of tag before
  10003080h 4h     GIF_CNT - Transfer status counter
  10003090h 4h     GIF_P3CNT - PATH3 transfer status counter
  100030A0h 4h     GIF_P3TAG - Bits 0-31 of PATH3 tag when interrupted
  10006000h 10h    GIF FIFO
</TD></TR></TABLE>
<B>DMA Controller (DMAC)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  100080xxh        VIF0 - channel 0
  100090xxh        VIF1 - channel 1
  1000A0xxh        GIF - channel 2
  1000B0xxh        IPU_FROM - channel 3
  1000B4xxh        IPU_TO - channel 4
  1000C0xxh        SIF0 - channel 5
  1000C4xxh        SIF1 - channel 6
  1000C8xxh        SIF2 - channel 7
  1000D0xxh        SPR_FROM - channel 8
  1000D4xxh        SPR_TO - channel 9
  1000E000h 4h     D_CTRL - DMAC control
  1000E010h 4h     D_STAT - DMAC interrupt status
  1000E020h 4h     D_PCR - DMAC priority control
  1000E030h 4h     D_SQWC - DMAC skip quadword
  1000E040h 4h     D_RBSR - DMAC ringbuffer size
  1000E050h 4h     D_RBOR - DMAC ringbuffer offset
  1000E060h 4h     D_STADR - DMAC stall address
  1000F520h 4h     D_ENABLER - DMAC disabled status
  1000F590h 4h     D_ENABLEW - DMAC disable
</TD></TR></TABLE>
<B>Interrupt Controller (INTC)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1000F000h 4h     INTC_STAT - Interrupt status
  1000F010h 4h     INTC_MASK - Interrupt mask
</TD></TR></TABLE>
<B>Subsystem Interface (SIF)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1000F200h 4h     MSCOM - EE->IOP communication
  1000F210h 4h     SMCOM - IOP->EE communication
  1000F220h 4h     MSFLAG - EE->IOP flags
  1000F230h 4h     SMFLAG - IOP->EE flags
  1000F240h 4h     Control register
</TD></TR></TABLE>
<B>Privileged GS registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  12000000h 8h     PMODE - various PCRTC controls
  12000010h 8h     SMODE1
  12000020h 8h     SMODE2
  12000030h 8h     SRFSH
  12000040h 8h     SYNCH1
  12000050h 8h     SYNCH2
  12000060h 8h     SYNCV
  12000070h 8h     DISPFB1 - display buffer for output circuit 1
  12000080h 8h     DISPLAY1 - output circuit 1 control
  12000090h 8h     DISPFB2 - display buffer for output circuit 2
  120000A0h 8h     DISPLAY2 - output circuit 2 control
  120000B0h 8h     EXTBUF
  120000C0h 8h     EXTDATA
  120000D0h 8h     EXTWRITE
  120000E0h 8h     BGCOLOR - background color
  12001000h 8h     GS_CSR - control register
  12001010h 8h     GS_IMR - GS interrupt control
  12001040h 8h     BUSDIR - transfer direction
  12001080h 8h     SIGLBLID - signal
</TD></TR></TABLE><BR>
IOP Map<BR>
<B>Subsystem Interface (SIF)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1D000000h 4h     MSCOM - EE->IOP communication
  1D000010h 4h     SMCOM - IOP->EE communication
  1D000020h 4h     MSFLAG - EE->IOP flags
  1D000030h 4h     SMFLAG - IOP->EE flags
  1D000040h 4h     Control register
</TD></TR></TABLE>
<B>CDVD Drive</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1F402004h 1h     Current N command
  1F402005h 1h     N command status (R)
  1F402005h 1h     N command params (W)
  1F402006h 1h     Error
  1F402007h 1h     Send BREAK command
  1F402008h 1h     CDVD I_STAT - interrupt register
  1F40200Ah 1h     Drive status
  1F40200Fh 1h     Disk type
  1F402016h 1h     Current S command
  1F402017h 1h     S command status
  1F402018h 1h     S command params
</TD></TR></TABLE>
<B>Interrupt Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1F801070h 4h     I_STAT - Interrupt status
  1F801074h 4h     I_MASK - Interrupt mask
  1F801078h 1h     I_CTRL - Global interrupt disable
</TD></TR></TABLE>
<B>DMA registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1F80108xh        MDECin - channel 0
  1F80109xh        MDECout - channel 1
  1F8010Axh        SIF2 (GPU) - channel 2
  1F8010Bxh        CDVD - channel 3
  1F8010Cxh        SPU2 Core0 - channel 4
  1F8010Dxh        PIO - channel 5
  1F8010Exh        OTC - channel 6
  1F80150xh        SPU2 Core1 - channel 8
  1F80151xh        ??? - channel 9
  1F80152xh        SIF0 - channel 10
  1F80153xh        SIF1 - channel 11
  1F80154xh        SIO2in - channel 12
  1F80155xh        SIO2out - channel 13
  
  1F8010F0h 4h     DPCR - DMA priority control
  1F8010F4h 4h     DICR - DMA interrupt control
  1F801570h 4h     DPCR2 - DMA priority control 2
  1F801574h 4h     DICR2 - DMA priority control 2
</TD></TR></TABLE>
<B>IOP Timers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1F80110xh        Timer 0
  1F80111xh        Timer 1
  1F80112xh        Timer 2
  1F80148xh        Timer 3
  1F80149xh        Timer 4
  1F8014Axh        Timer 5
</TD></TR></TABLE>
<B>Serial Interface (SIO2)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1F808200h 40h    SEND3 buffer
  1F808240h 20h    SEND1/2 buffers
  1F808260h 1h     In FIFO
  1F808264h 1h     Out FIFO
  1F808268h 4h     SIO2 control
  1F80826Ch 4h     RECV1
  1F808270h 4h     RECV2
  1F808274h 4h     RECV3
</TD></TR></TABLE>
<B>Sound Processing Unit (SPU2)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1F900000h 180h   Core0 Voice 0-23 registers
  1F900190h 4h     Key ON 0/1
  1F900194h 4h     Key OFF 0/1
  1F90019Ah 2h     Core attributes
  1F90019Ch 4h     Interrupt address H/L
  1F9001A8h 4h     DMA transfer address H/L
  1F9001ACh 2h     Internal transfer FIFO
  1F9001B0h 2h     AutoDMA status
  1F9001C0h 120h   Core0 Voice 0-23 start/loop/next addresses
  1F900340h 4h     ENDX 0/1
  1F900344h 2h     Status register
  
  ... above addresses repeat for Core1 starting at 1F900400h ...
  
  1F900760h 2h     Master Volume Left
  1F900762h 2h     Master Volume Right
  1F900764h 2h     Effect Volume Left
  1F900766h 2h     Effect Volume Right
  1F900768h 2h     Core1 External Input Volume Left
  1F90076Ah 2h     Core1 External Input Volume Right
</TD></TR></TABLE><BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gif"></A>&nbsp;
Graphics Interface (GIF)
</FONT></TD></TR></TABLE><BR>
The GIF sends textures and geometry to the GS. It takes data from three different PATHs:<BR>
 - PATH1: VU1 via XGKICK instruction. Highest priority.<BR>
 - PATH2: VIF1 via DIRECT/DIRECTHL. Medium priority.<BR>
 - PATH3: GIF DMAC channel (channel 2). Lowest priority.<BR>
Only one PATH may run at a time.
Under normal conditions, when one PATH stops, the highest priority queued PATH will begin transfer.<BR>
<BR>
<B>GIF Reference</B><BR>
<A HREF="#gifio">GIF I/O</A><BR>
<A HREF="#giftags">GIFtags</A><BR>
<A HREF="#gifdataformats">GIF Data Formats</A><BR>
<A HREF="#gifpath3masking">GIF PATH3 Masking</A><BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gifio"></A>&nbsp;
GIF I/O
</FONT></TD></TR></TABLE><BR>
<B>10003000h GIF_CTRL - Control register (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Reset GIF
  1-2   Unused
  3     Temporary stop (1=stop transfers, 0=restart transfers)
  4-31  Unused
</TD></TR></TABLE><BR>
<B>10003010h GIF_MODE - Mode of operation (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Mask PATH3 (1=Mask)
  1     Unused
  2     Intermittent mode
</TD></TR></TABLE>
When PATH3 is masked by this register and GIF DMA is ongoing, the mask applies once GIF DMA ends its transfer.<BR>
<BR>
<B>10003020h GIF_STAT - Status register (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     PATH3 masked by GIF_MODE
  1     PATH3 masked by VIF1 MASKP3 register
  2     Intermittent mode activated
  3     Temporary stop 
  4     Unused
  5     PATH3 interrupted (by intermittent mode?)
  6     PATH3 queued
  7     PATH2 queued
  8     PATH1 queued
  9     Output path (1=transfer ongoing)
  10-11 Active path
        0=Idle
        1=PATH1
        2=PATH2
        3=PATH3
  12    Transfer direction (0=EE->GS, 1=GS->EE)
  13-23 Unused
  24-28 Data in GIF FIFO (in quadwords, max 16)
  29-31 Unused
</TD></TR></TABLE><BR>
<B>10003040h GIF_TAG0 (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Bits 0-31 of most recently read GIFtag
</TD></TR></TABLE>
<B>10003050h GIF_TAG1 (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Bits 32-63 of most recently read GIFtag
</TD></TR></TABLE>
<B>10003060h GIF_TAG2 (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Bits 64-95 of most recently read GIFtag
</TD></TR></TABLE>
<B>10003070h GIF_TAG3 (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Bits 96-127 of most recently read GIFtag
</TD></TR></TABLE>
These registers are only readable when the GIF has been paused by GIF_CTRL.<BR>
For details on the GIFtag format, see<BR>
<A HREF="#giftags">GIFtags</A><BR>
<BR>
<B>10003080h GIF_CNT (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-14  Backwards loop counter from NLOOP
        Decrements to zero
  15    Unused
  16-19 Register descriptor in progress
        0=highest
        1=lowest
        2=2nd lowest
        ...
        15=15th lowest
  20-29 VU data address being transferred
  30-31 Unused
</TD></TR></TABLE>
Only accessible when GIF is paused by GIF_CTRL.<BR>
<BR>
<B>10003090h GIF_P3CNT (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-14  Backwards loop counter from PATH3 NLOOP when PATH3 is interrupted
  15-31 Unused
</TD></TR></TABLE>
Only accessible when GIF is paused by GIF_CTRL.<BR>
<BR>
<B>100030A0h GIF_P3TAG (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Bits 0-31 of PATH3 GIFtag when PATH3 is interrupted
</TD></TR></TABLE>
Only accessible when GIF is paused by GIF_CTRL.<BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="giftags"></A>&nbsp;
GIFtags
</FONT></TD></TR></TABLE><BR>
The basic unit of GIF transfer data is the GIF packet.
Each packet is split into one or more primitives. Every primitive must be preceded by a GIFtag.<BR>
<BR>
<B>GIFtag Format</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-14    NLOOP - Data per register to transfer
  15      EOP - End of packet
  16-45   Unused
  46      Enable PRIM field
  47-57   Data to be sent to GS PRIM register if GIFtag.46 == 1
  58-59   Data format
          0=PACKED
          1=REGLIST
          2=IMAGE
          3=IMAGE
  60-63   NREGS - Number of registers
          0=16 registers
  64-127  Register field, 4 bits each
</TD></TR></TABLE><BR>
When NLOOP == 0, all fields are ignored except EOP and no further processing is done.<BR>
When GIFtag.46 == 0, an idle cycle is inserted before processing begins.<BR>
Registers are handled in little-endian order; i.e. bits 64-67 are processed first, then 68-71, and so on.<BR>
<BR>
NOTE: The GS Q register is initialized to 1.0f when reading a GIFtag.<BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gifdataformats"></A>&nbsp;
GIF Data Formats
</FONT></TD></TR></TABLE><BR>
The data format after a GIFtag varies depending on the value of GIFtag.58-59.
The GIF can transfer to the GS in PACKED, REGLIST, or IMAGE formats.<BR>
<BR>
<B>PACKED Format</B><BR>
Data is transferred in units of quadwords (16 bytes).
Total amount of data in the GIF primitive = NLOOP * NREGS.<BR>
All registers not specified below output the lower 64-bits of the quadword to their GS register directly.
The upper 64-bits are discarded.<BR>
<BR>
<B>Current reg=0h PRIM</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-10    Data to write to GS PRIM
  11-127  Unused
</TD></TR></TABLE><BR>
<B>Current reg=1h RGBA</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Writes to RGBAQ register (Q is unchanged)
  0-7     R
  8-31    Unused
  32-39   G
  40-63   Unused
  64-71   B
  72-95   Unused
  96-103  A
  104-127 Unused
</TD></TR></TABLE>
R, G, B, and A are 8-bit values. Q is set by the STQ command.<BR>
<BR>
<B>Current reg=2h STQ</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Writes to ST register and Q component of RGBAQ.
  0-31    S
  32-63   T
  64-95   Q
  96-127  Unused
</TD></TR></TABLE>
S, T, and Q are single-precision (32-bit) floats in IEEE 754 format.<BR>
<BR>
<B>Current reg=3h UV</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-13    U
  14-31   Unused
  32-45   V
  46-127  Unused
</TD></TR></TABLE>
U and V are 14-bit unsigned fixed-point integers with a 4-bit fractional component.<BR>
<BR>
<B>Current reg=4h XYZ2F/XYZ3F</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15    X
  16-31   Unused
  32-47   Y
  48-67   Unused
  68-91   Z
  92-99   Unused
  100-107 F
  108-110 Unused
  111     Disable drawing (1=write to XYZ3F, 0=write to XYZ2F)
  112-127 Unused
</TD></TR></TABLE>
X and Y are signed 16-bit fixed-point integers with a 4-bit fractional component.<BR>
Z is a 24-bit integer, and F is an 8-bit integer.<BR>
The "disable drawing" bit controls whether the data is written to XYZ2F or XYZ3F.<BR>
<BR>
<B>Current reg=5h XYZ2/XYZ3</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15    X
  16-31   Unused
  32-47   Y
  48-63   Unused
  64-95   Z
  96-110  Unused
  111     Disable drawing (1=write to XYZ3F, 0=write to XYZ2F)
  112-127 Unused
</TD></TR></TABLE>
Similar to XYZ2F/XYZ3F above, except there is no F register and Z is 32-bit.<BR>
<BR>
<B>Current reg=Ah FOG</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-99    Unused
  100-107 F
  108-127 Unused
</TD></TR></TABLE><BR>

<B>Current reg=Eh A+D (output data to specified address)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-63    Data
  64-71   Register address
  72-127  Unused
</TD></TR></TABLE>
Outputs data to the given register address.<BR>
<BR>
WARNING: Do not use this register descriptor on PATH3 when PATH1 is also running, or the GS may lock up!<BR>
<BR>
<B>Current reg=Fh NOP</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Data not output to GS.
</TD></TR></TABLE><BR>
  
<B>REGLIST Format</B><BR>
Total data in GIF primitive = NREGS * NLOOP, in units of doublewords. (64-bits)<BR>
In REGLIST, a doubleword is sent directly to the register descriptor.
Every quadword contains data for two registers.
When the data is prepared properly, this can multiply data density by up to a factor of 2.<BR>
When NREGS * NLOOP is odd, the last doubleword in a primitive is discarded.<BR>
<BR>
<B>IMAGE Format</B><BR>
Total data in GIF primitive = NLOOP only, in units of quadwords.<BR>
IMAGE is a shortcut for writing to the GS HWREG register, which transfers textures and other data to VRAM.
Each quadword has enough data for two writes to HWREG.<BR>
<BR>
<BR>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gifpath3masking"></A>&nbsp;
GIF PATH3 Masking
</FONT></TD></TR></TABLE><BR>
PATH1 and PATH2 transfer to the GS without any internal buffering.
However, PATH3 has a 16-quadword GIF FIFO.<BR>
When PATH3 masking is enabled, data sent by PATH3 will reside in the FIFO until the mask is lifted.
This is useful for queueing texture transfers while other paths are sending geometry. 
GTA: San Andreas, Lemmings, and some other games rely on this.<BR>
<BR>
Furthermore, Wallace and Gromit at Project Zoo will enable the mask and start a GIF DMA transfer, expecting it to finish.
Emulating PATH3 masking without emulating the GIF FIFO will cause it to hang on a black screen,
as the DMA channel is unable to write any data.<BR>
<BR>
<BR>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="dmac"></A>&nbsp;
DMA Controller (DMAC)
</FONT></TD></TR></TABLE><BR>
The DMAC gives an interface for the EE to access the rest of the system.
It can transfer one quadword (16 bytes) at bus speed (half the rate of the EE's clock).<BR>
<BR>
<B>DMAC Reference</B><BR>
<A HREF="#dmacio">DMAC I/O</A><BR>
<A HREF="#dmacchainmode">DMAC Chain Mode</A><BR>
<A HREF="#dmacint">DMAC Interrupts</A><BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="dmacio"></A>&nbsp;
DMAC I/O
</FONT></TD></TR></TABLE><BR>
<B>Channels</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  100080xxh    VIF0
  100090xxh    VIF1 (can act as PATH2 for GIF)
  1000A0xxh    GIF (PATH3)
  1000B0xxh    IPU_FROM
  1000B4xxh    IPU_TO
  1000C0xxh    SIF0 (from IOP)
  1000C4xxh    SIF1 (to IOP)
  1000C8xxh    SIF2 (bidirectional, used for PSX mode and debugging)
  1000D0xxh    SPR_FROM
  1000D4xxh    SPR_TO
</TD></TR></TABLE><BR>
<B>1000xx00h Dn_CHCR - Channel control (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     DIR - Direction (0=to memory, 1=from memory)
        Only effective for VIF1 and SIF2
  1     Unused
  2-3   MOD - Mode (0=normal, 1=chain, 2=interleave)
  4-5   ASP - Address stack pointer
  6     TTE - Transfer DMAtag (only in source chain mode)
  7     TIE - Enable IRQ bit in DMAtag
  8     STR - Start/busy
  9-15  Unused
  16-31 TAG - Bits 16-31 of most recently read DMAtag
</TD></TR></TABLE><BR>

<B>1000xx10h Dn_MADR - Channel address (R/W)</B><BR>
<B>1000xx30h Dn_TADR - Channel tag address (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-30  Address (lower 4 bits must be zero)
  31    Memory selection (0=RAM, 1=scratchpad)
</TD></TR></TABLE>
The channel will read from/write to MADR directly during a transfer. TADR is only used for chain mode.<BR>
MADR and TADR update while a transfer is ongoing, i.e., the DMAC has no internal channels for memory addresses.<BR>
Certain games expect MADR and TADR to increment during a transfer.<BR>
<BR>
  
<B>1000xx20h Dn_QWC - Quadword count (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Quadwords
  16-31 Unused
</TD></TR></TABLE>
In normal and interleaved mode, the transfer ends when QWC reaches zero. Chain mode behaves differently; see<BR>
<A HREF="#dmacchainmode">DMAC Chain Mode</A><BR>
<BR>

<B>1000xx40h Dn_ASR0 - Channel saved tag address (R/W)</B><BR>
<B>1000xx50h Dn_ASR1 - Channel saved tag address (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-30  Tag address (lower 4 bits must be zero)
  31    Memory selection (0=RAM, 1=scratchpad)
</TD></TR></TABLE>
ASR0/ASR1 can only be used by the VIF0, VIF1, and GIF channels.<BR>
<BR>

<B>1000xx80h Dn_SADR - Channel scratchpad address (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-13  Address (lower 4 bits must be zero)
  14-31 Unused
</TD></TR></TABLE>
SADR is only used by SPR_FROM and SPR_TO.<BR>
<BR>
  
<B>1000E000h D_CTRL - DMAC control (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    DMA enable
  1    Cycle stealing on
  2-3  MFIFO drain channel
       0=None
       1=Reserved
       2=VIF1
       3=GIF
  4-5  Stall control channel
       0=None
       1=SIF0
       2=SPR_FROM
       3=IPU_FROM
  6-7  Stall control drain channel
       0=None
       1=VIF1
       2=GIF
       3=SIF1
  8-10 Release cycle period
       0=8
       1=16
       2=32
       3=64
       4=128
       5=256
</TD></TR></TABLE>
When cycle stealing is on, the release cycle period controls how long the EE has control of the bus.<BR>
<BR>
<B>1000E010h D_STAT - DMAC interrupt status (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-9    Channel interrupt status (1=IRQ, write 1 to clear)
  10-12  Unused
  13     DMA stall interrupt status
  14     MFIFO empty interrupt status
  15     BUSERR interrupt status
  16-25  Channel interrupt mask (1=enabled, write 1 to reverse)
  26-28  Unused
  29     Stall interrupt mask
  30     MFIFO empty mask
</TD></TR></TABLE>
INT1 is asserted when (status & mask) != 0.<BR>
<BR>
<B>1000E020h D_PCR - DMAC priority control (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-9    COP0 condition control
  10-15  Unused
  16-25  Channel priority (0=Channel disabled, only if D_PCR.31 is true)
  26-30  Unused
  31     Priority enable
</TD></TR></TABLE>
COP0 control determines whether or not CPCOND0 is activated.
If (~control | D_STAT.0-9) == 0x3FF, CPCOND0 is set.
This is useful for knowing when multiple DMA transfers have finished without using interrupts.<BR>
<BR>
<B>1000E030h D_SQWC - DMAC skip quadword (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   Quadwords to skip
  8-15  Unused
  16-23 Quadwords to transfer
  24-31 Unused
</TD></TR></TABLE>
In interleave mode, every time D_SQWC.16-23 quadwords have been transferred, D_SQWC.0-7 quadwords are skipped.<BR>
<BR>
<B>1000E040h D_RBSR - DMAC ringbuffer size (R/W)</B><BR>
<BR>
<B>1000E050h D_RBOR - DMAC ringbuffer offset (R/W)</B><BR>
<BR>
<B>1000F520h D_ENABLER - DMAC disabled status (R)</B><BR>
<B>1000F590h D_ENABLEW - DMAC disable (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  16    DMAC disabled
  All other bits appear to be garbage, but writable
  SCPH-39001 (and other BIOSes?) seems to expect D_ENABLER to be set to 1201h upon boot
</TD></TR></TABLE><BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="dmacchainmode"></A>&nbsp;
DMAC Chain Mode
</FONT></TD></TR></TABLE><BR>
The DMAC can intelligently chain DMA transfers together.
When a transfer starts in chain mode, the channel will transfer QWC quadwords and then read a DMAtag.<BR>
In source chain mode, the DMAtag comes from TADR.
In destination chain mode, the DMAtag comes from the peripheral the channel is reading from.<BR>
<BR>
<B>DMAtag</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15    QWC to transfer
  16-25   Unused
  26-27   Priority control
          0=No effect
          1=Reserved
          2=Priority control disabled (D_PCR.31 = 0)
          3=Priority control enabled (D_PCR.31 = 1)
  28-30   Tag ID
  31      IRQ
  32-62   ADDR field (lower 4 bits must be zero)
  63      Memory selection for ADDR (0=RAM, 1=scratchpad)
  64-127  Data to transfer (only if Dn_CHCR.TTE==1)
</TD></TR></TABLE>
When both IRQ and Dn_CHCR.TIE are set, the transfer ends after QWC has been transferred.<BR>
When Dn_CHCR.TTE is on, bits 64-127 are transferred BEFORE QWC.<BR>
The effects of the tag ID vary depending on if the channel is in source chain or dest chain mode.<BR>
<BR>
<B>Source Chain Tag ID</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    refe    MADR=DMAtag.ADDR
               TADR+=16
               tag_end=true
  
  1    cnt     MADR=TADR+16 (next to DMAtag)
               TADR=MADR (next to transfer data)
  
  2    next    MADR=TADR+16
               TADR=DMAtag.ADDR
  
  3    ref     MADR=DMAtag.ADDR
               TADR+=16
  
  4    refs    MADR=DMAtag.ADDR
               TADR+=16
  
  5    call    MADR=TADR+16
               if (CHCR.ASP == 0)
                 ASR0=MADR+(QWC*16)
               else if (CHCR.ASP == 1)
                 ASR1=MADR+(QWC*16)
               TADR=DMAtag.ADDR
               CHCR.ASP++
  
  6    ret     MADR=TADR+16
               if (CHCR.ASP == 2)
                 TADR=ASR1
                 CHCR.ASP--
               else if (CHCR.ASP == 1)
                 TADR=ASR0
                 CHCR.ASP--
               else
                 tag_end=true
  
  7    end     MADR=TADR+16
                 tag_end=true
               
</TD></TR></TABLE>
When tag_end=true, the transfer ends after QWC has been transferred.<BR>
<BR>
<B>Dest Chain Tag ID</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    cnt     MADR=DMAtag.ADDR
  
  1    cnts    MADR=DMAtag.ADDR
  
  7    end     MADR=DMAtag.ADDR
               tag_end=true
</TD></TR></TABLE><BR>
<B>DMA Resuming</B><BR>
If a transfer starts in source chain mode and QWC > 0,
the DMAC assumes that the TAG field of CHCR was the last read DMAtag.
This means that if the tag ID is REFE or END, the channel will stop after QWC has been transferred.<BR>
Sony's movie-playing library requires this behavior,
as it uses MADR to determine the current movie buffer position.<BR>
<BR>
<BR>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="dmacint"></A>&nbsp;
DMAC Interrupts
</FONT></TD></TR></TABLE><BR>
Upon any transfer completion, the DMAC will raise the channel's stat flag in D_STAT.
When (stat & mask) != 0, the DMAC asserts an INT1 signal to the EE.<BR>
INT1 may also be asserted when MFIFO is empty, a stall occurs, or a bus error occurs.
The bus error is not maskable via D_STAT.<BR>
NOTE: INT0 (INTC) has priority over INT1.
If INT0 and INT1 are asserted at the same time, the INT0 interrupt will be processed first.<BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gs"></A>&nbsp;
Graphics Synthesizer (GS)
</FONT></TD></TR></TABLE><BR>
<B>GS Reference</B><BR>
<A HREF="#gsregisterlist">GS Register List</A><BR>
<A HREF="#gsprimitives">GS Primitives</A><BR>
<A HREF="#gsvertexattributes">GS Vertex Attributes</A><BR>
<A HREF="#gsframeandzbuffers">GS Frame and Z Buffers</A><BR>
<A HREF="#gstransfers">GS Transfers</A><BR>
<A HREF="#gstextures">GS Textures</A><BR>
<A HREF="#gsfog">GS Fog</A><BR>
<A HREF="#gsalphablending">GS Alpha Blending</A><BR>
<A HREF="#gstestsandpixelcontrol">GS Tests and Pixel Control</A><BR>
<BR>
<BR>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gsregisterlist"></A>&nbsp;
GS Register List
</FONT></TD></TR></TABLE><BR>
<B>Internal registers (accessible via GIF)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h     PRIM
  01h     RGBAQ
  02h     ST
  03h     UV
  04h     XYZF2
  05h     XYZ2
  06h/07h TEX0_1/2
  08h/09h CLAMP_1/2
  0Ah     FOG
  0Ch     XYZF3
  0Dh     XYZ3
  14h/15h TEX1_1/2
  16h/17h TEX2_1/2
  18h/19h XYOFFSET_1/2
  1Ah     PRMODECONT
  1Bh     PRMODE
  1Ch     TEXCLUT
  22h     SCANMSK
  34h/35h MIPTBP1_1/2
  36h/37h MIPTBP2_1/2
  3Bh     TEXA
  3Dh     FOGCOL
  3Fh     TEXFLUSH
  40h/41h SCISSOR_1/2
  42h/43h ALPHA_1/2
  44h     DIMX
  45h     DTHE
  46h     COLCLAMP
  47h/48h TEST_1/2
  49h     PABE
  4Ah/4Bh FBA_1/2
  4Ch/4Dh FRAME_1/2
  4Eh/4Fh ZBUF_1/2
  50h     BITBLTBUF
  51h     TRXPOS
  52h     TRXREG
  53h     TRXDIR
  54h     HWREG
  60h     SIGNAL
  61h     FINISH
  62h     LABEL
</TD></TR></TABLE><BR>
<B>Privileged registers (accessible via EE)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  12000000h    PMODE
  12000020h    SMODE2
  12000070h    DISPFB1
  12000080h    DISPLAY1
  12000090h    DISPFB2
  120000A0h    DISPLAY2
  120000B0h    EXTBUF
  120000C0h    EXTDATA
  120000D0h    EXTWRITE
  120000E0h    BGCOLOR
  12001000h    CSR
  12001010h    IMR
  12001040h    BUSDIR
  12001080h    SIGLBLID
</TD></TR></TABLE><BR>
<BR>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gsprimitives"></A>&nbsp;
GS Primitives
</FONT></TD></TR></TABLE><BR>
The GS supports point, line, triangle, and sprite (2D rectangle with two points) primitives.<BR>
<BR>
<B>00h PRIM</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-2   Primitive type
        0=Point
        1=Line
        2=LineStrip
        3=Triangle
        4=TriangleStrip
        5=TriangleFan
        6=Sprite
        7=Reserved
  3     Gourand shading
  4     Texture mapping
  5     Fog
  6     Alpha blending
  7     Antialiasing
  8     Use UV for texture coordinates (0=Use STQ)
  9     Use Context 2's registers for drawing (0=Use Context 1)
  10    Fix fragment value (related to antialiasing?)
</TD></TR></TABLE><BR>
<B>1Ah PRMODECONT</B><BR>
When this register is set to 1, bits 3-10 in PRIM are used when rendering primitives.
Otherwise, bits 3-10 in PRMODE are used.<BR>
<BR>
<B>1Bh PRMODE</B><BR>
Same as PRIM, except bits 0-2 are unused.<BR>
PRMODE can be useful when you want to draw multiple primitives with different attributes but the same type.<BR>
<BR>
<BR>
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gsvertexattributes"></A>&nbsp;
GS Vertex Attributes
</FONT></TD></TR></TABLE><BR>
<B>01h RGBAQ</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7    Red
  8-15   Green
  16-23  Blue
  24-31  Alpha
  32-63  Q
</TD></TR></TABLE>
These attributes are applied to newly created vertices.<BR>
<BR>
<B>04h/0Ch XYZF2/XYZF3</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15   X
  16-31  Y
  32-55  Z
  56-63  Fog coefficient (placed in FOG register)
</TD></TR></TABLE>
This defines a new vertex to be placed in the vertex queue, a process known as the vertex kick.
X and Y are 12-bit fixed-point integers with a 4-bit fractional component, ranging from 0 to 4095.9375.<BR>
When 1, 2, or 3 vertices have been defined as per the primitive type, a "drawing kick" occurs,
where the GS begins drawing the primitive.<BR>
NOTE: Drawing kicks can only occur on XYZF2! XYZF3 will clear the queue as needed but will not draw any primitives.
XYZF3 exists to allow the programmer to easily cull polygons, as the GS has no native support for culling.<BR>
<BR>
See <A HREF="#gsfog">GS Fog</A> for details on fog.<BR>
<BR>
<B>05h/0Dh XYZ2/XYZ3</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15   X
  16-31  Y
  32-63  Z
</TD></TR></TABLE>
Same as XYZF2/XYZF3, except Z is a 32-bit unsigned integer rather than a 24-bit unsigned integer.<BR>
XYZ2 can also result in a drawing kick, whereas XYZ3 cannot.<BR>
<BR>
<B>18h/19h XYOFFSET_1/2</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15   X
  32-47  Y
</TD></TR></TABLE>
When a vertex kick occurs, XYOFFSET is subtracted from the vertex's X and Y coordinates.<BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gsframeandzbuffers"></A>&nbsp;
GS Frame and Z Buffers
</FONT></TD></TR></TABLE><BR>
<B>4Ch/4Dh FRAME_1/2</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-8    Base pointer in words/2048
  16-21  Buffer width in pixels/64
  24-29  Format
         00h=PSMCT32
         01h=PSMCT24
         02h=PSMCT16
         0Ah=PSMCT16S
         30h=PSMZ32
         31h=PSMZ24
         32h=PSMZ16
         3Ah=PSMZ16S
  32-63  Framebuffer mask
</TD></TR></TABLE>
Bits 32-63 prevent the specified bits in the framebuffer from being updated by the following formula:<BR>
final_color = (final_color & ~mask) | (frame_color & mask)<BR>
This mask is applied before format conversions, e.g., bit 63 of FRAME will affect bit 15 (alpha bit) of a 16-bit color.<BR>
<BR>
<B>4Eh/4Fh ZBUF_1/2</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-8    Base pointer in words/2048
  24-27  Format
         00h=PSMZ32
         01h=PSMZ24
         02h=PSMZ16
         0Ah=PSMZ16S
  32     Buffer mask (1=do not update zbuffer)
</TD></TR></TABLE>
The zbuffer's width is the same as the framebuffer's, specified in FRAME.<BR>
<BR>
<BR>
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gstransfers"></A>&nbsp;
GS Transfers
</FONT></TD></TR></TABLE><BR>
The GS supports GIF->VRAM, VRAM->VRAM, and VRAM->GIF data transfers.<BR>
<BR>
<B>50h BITBLTBUF</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-13    Source base pointer in words/64
  16-21   Source buffer width in pixels/64
  24-29   Source format
          00h=PSMCT32
          01h=PSMCT24
          02h=PSMCT16
          0Ah=PSMCT16S
          13h=PSMCT8
          14h=PSMCT4
          1Bh=PSMCT8H
          24h=PSMCT4HL
          2Ch=PSMCT4HH
          30h=PSMZ32
          31h=PSMZ24
          32h=PSMZ16
          3Ah=PSMZ16S
  32-45   Destination base pointer in words/64
  48-53   Destination buffer width in pixels/64
  56-61   Destination format (same as source format)
</TD></TR></TABLE>
In VRAM->VRAM transfers, the source and destination formats must have the same bits per pixel.<BR>
<BR>
<B>51h TRXPOS</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-10    X for source rectangle
  16-26   Y for source rectangle
  32-42   X for destination rectangle
  48-58   Y for destination rectangle
  59-60   Transmission order for VRAM->VRAM transfers
          0=Upper-left->lower-right
          1=Lower-left->upper-right
          2=Upper-right->lower-left
          3=Lower-right->upper-left
</TD></TR></TABLE>
X and Y are in units of pixels and define the upper-left corner of their respective rectangle.<BR>
NOTE: During transfer, X and Y wrap around if they exceed 2048, e.g., by the following formula:<BR>
  X = (TRXPOS.X + TRXREG.width) % 2048<BR>
<BR>
<B>52h TRXREG</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-11    Width in pixels of transmission area
  32-43   Height in pixels of transmission area
</TD></TR></TABLE><BR>
<B>53h TRXDIR</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1     Transmission direction
          0=GIF->VRAM
          1=VRAM->GIF
          2=VRAM->VRAM
          3=Deactivated
</TD></TR></TABLE>
Note that the privileged register BUSDIR must be set appropriately for GIF->VRAM and VRAM->GIF.<BR>
<BR>
<B>54h HWREG</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-63    Data to be transferred for GIF->VRAM
</TD></TR></TABLE>
The "IMAGE" GIFtag format is a shortcut for writing to this register. Data is packed according to the format.
For example, PSMCT4 will have 16 4-bit pixels per doubleword.<BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gstextures"></A>&nbsp;
GS Textures
</FONT></TD></TR></TABLE><BR>
<B>06h/07h TEX0_1/2</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-13    Base pointer in words/64
  14-19   Buffer width in pixels/64
  20-25   Texture format
          00h=PSMCT32
          01h=PSMCT24
          02h=PSMCT16
          0Ah=PSMCT16S
          13h=PSMCT8
          14h=PSMCT4
          1Bh=PSMCT8H
          24h=PSMCT4HL
          2Ch=PSMCT4HH
          30h=PSMZ32
          31h=PSMZ24
          32h=PSMZ16
          3Ah=PSMZ16S
  26-29   Texture width (width = min(2^value, 1024))
  30-33   Texture height (height = min(2^value, 1024))
  34      Alpha control (0=texture is RGB, 1=texture is RGBA)
  35-36   Color function
          0=Modulate
          1=Decal
          2=Highlight
          3=Highlight2
  37-50   CLUT base pointer in words/64
  51-54   CLUT format
          00h=PSMCT32
          02h=PSMCT16
          0Ah=PSMCT16S
  55      CLUT uses CSM2 (0=CSM1)
  56-60   CLUT entry offset/16 (In CSM2, this value must be 0)
  61-63   CLUT cache control
          0=Do not reload cache
          1=Reload cache
          2=Reload cache and copy CLUT base pointer to CBP0
          3=Reload cache and copy CLUT base pointer to CBP1
          4=IF CLUT base pointer != CBP0, reload cache and copy pointer to CBP0
          5=IF CLUT base pointer != CBP1, reload cache and copy pointer to CBP1
</TD></TR></TABLE><BR>
<B>14h/15h TEX1_1/2</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0       LOD (level of detail) calculation method
          0=LOD=(log2(1/abs(Q))<<L)+K
          1=LOD=K
  2-4     Max mipmap level (0-6)
  5       Magnification filter: Use bilinear filtering when LOD < 0 (0=nearest filtering)
  6-8     Filter when LOD >= 0 (reduced texture)
          0=nearest
          1=bilinear
          2=nearest_mipmap_nearest
          3=nearest_mipmap_bilinear
          4=bilinear_mipmap_nearest
          5=bilinear_mipmap_bilinear
  9       Automatic calculation of mipmap levels 1-3 (0=use MIPTBP1)
  19-20   L parameter
  32-43   K parameter (signed fixed-point, 7 bits whole, 4 bits fractional)
</TD></TR></TABLE><BR>
<B>16h/17h TEX2_1/2</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  20-25   Texture format (same as TEX0)
  37-50   CLUT base pointer in words/64
  51-54   CLUT format
  55      CLUT uses CSM2 (0=CSM1)
  56-60   CLUT entry offset/16
  61-63   CLUT cache control (same as TEX0)
</TD></TR></TABLE>
TEX2 is a subset of TEX0. This is useful for modifying texture format and CLUT information when the texture base pointer,
width, etc. must stay the same.<BR>
<BR>
<B>3Fh TEXFLUSH</B><BR>
Writing any value to this register will invalidate the texture cache. Do this in the following situations:<BR>
- Using newly transferred texture data<BR>
- Using newly transferred CLUT data or reloading the CLUT cache<BR>
- Using framebuffer or zbuffer data as textures<BR>
<BR>
<B>Texture coordinates</B><BR>
The GS supports STQ texture coordinates and UV texel coordinates. The relationship between the two is as follows.<BR>
U=(S/Q)*TEX0.texwidth<BR>
V=(T/Q)*TEX0.texheight<BR>
<BR>
Q is defined by RGBAQ and used for perspective correction. 
It is not possible to use perspective correction when directly using UV coordinates.<BR>
<BR>
<B>02h ST</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31    S (lower 8 bits are rounded down to zero)
  32-63   T (lower 8 bits are rounded down to zero)
</TD></TR></TABLE>
S and T are (mostly) IEEE 754-compliant single-precision floating-point values.
For both S and T, the range [0.0, 1.0] refers to the whole texture.<BR>
<BR>
<B>03h UV</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-13    U
  16-29   V
</TD></TR></TABLE>
U and V are unsigned 10-bit fixed-point integers with a 4-bit fractional component.
The ranges [0, TEXWIDTH] and [0, TEXHEIGHT] for U and V respectively refer to the whole texture.<BR>
<BR>
<B>Color function</B>
TEX0 defines four possible color functions that can be used to blend texture and vertex colors:
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
               RGB                            RGBA
  Modulate     Rv = (Rv * Rt) >> 7            <- Same
               Gv = (Gv * Gt) >> 7            <- Same
               Bv = (Bv * Bt) >> 7            <- Same
               Av = Av                        Av = (Av * At) >> 7
  Decal        Rv = Rt                        <- Same
               Gv = Gt                        <- Same
               Bv = Bt                        <- Same
               Av = Av                        Av = At
  Highlight    Rv = ((Rv * Rt) >> 7) + Av     <- Same
               Gv = ((Gv * Gt) >> 7) + Av     <- Same
               Bv = ((Bv * Bt) >> 7) + Av     <- Same
               Av = Av                        Av = At + Av
  Highlight2   Same as Highlight              Same as Highlight, but Av = At
</TD></TR></TABLE><BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gsfog"></A>&nbsp;
GS Fog
</FONT></TD></TR></TABLE><BR>
<B>3Dh FOGCOL</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   R
  8-15  G
  16-23 B
</TD></TR></TABLE>
FOGCOL represents the color of a "distant" object, or one enshrounded in fog. See below for details.<BR>
<BR>
<B>0Ah FOG</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7  Fog effect
</TD></TR></TABLE>
FOG gives a fog effect F to the current vertex. XYZ2F/XYZ3F also modify this register.<BR>
During rasterization, if fog is enabled in PRIM/PRMODE, F is linearly interpolated for all vertices.
The fog equation is then applied to an outputted texture color after the color function has been applied:<BR>
Output = ((F * input) >> 8) + (((255 - F) * FOGCOL) >> 8)<BR>
So a value of 0xFF results in no change and a value of 0 completely converts the color to FOGCOL.<BR>
You can see that fog equation is just another alpha blending equation.<BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gsalphablending"></A>&nbsp;
GS Alpha Blending
</FONT></TD></TR></TABLE><BR>
<B>42h/43h ALPHA_1/2</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   Spec A
  2-3   Spec B
  4-5   Spec C
  6-7   Spec D
  8-15  Alpha FIX
</TD></TR></TABLE>
The GS's alpha blending formula is fixed but it contains four variables that can be reconfigured:<BR>
Output = (((A - B) * C) >> 7) + D<BR>
A, B, and D are colors and C is an alpha value. Their specific values come from the ALPHA register:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
      A                B                C                   D
  0   Source RGB       Source RGB       Source alpha        Source RGB
  1   Framebuffer RGB  Framebuffer RGB  Framebuffer alpha   Framebuffer RGB
  2   0                0                FIX                 0
  3   Reserved         Reserved         Reserved            Reserved
</TD></TR></TABLE>
Internally, alpha-blending treats each color component as 9-bit. The output is then clamped accordingly by COLCLAMP.<BR>
<BR>
<B>46h COLCLAMP</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    8-bit signed clamp (0=8-bit AND)
</TD></TR></TABLE>
When COLCLAMP is 1, RGB components will be 0 if negative after alpha-blending or 0xFF if 0x100 or above. Otherwise,
each color component will be ANDed with 0xFF.<BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gstestsandpixelcontrol"></A>&nbsp;
GS Tests and Pixel Control
</FONT></TD></TR></TABLE><BR>
<B>40h/41h SCISSOR_1/2</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-10   X0
  16-26  X1
  32-42  Y0
  48-58  Y1
</TD></TR></TABLE>
SCISSOR defines a rectangle with 11-bit unsigned integer coordinates, which range from 0 to 2047.
During drawing, pixels that fall outside the boundaries of this rectangle fail automatically and are not processed.<BR>
<BR>
<B>47h/48h TEST_1/2</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0      Alpha test enabled
  1-3    Alpha test method
         0=NEVER (all pixels fail)
         1=ALWAYS (all pixels pass)
         2=LESS (pixel alpha < AREF passes)
         3=LEQUAL (pixel alpha <= AREF passes)
         4=EQUAL (pixel alpha == AREF passes)
         5=GEQUAL (pixel alpha >= AREF passes)
         6=GREATER (pixel alpha > AREF passes)
         7=NEQUAL (pixel alpha != AREF passes)
  4-11   AREF
  12-13  Alpha test failure processing
         0=Neither framebuffer nor zbuffer are updated.
         1=Only framebuffer is updated.
         2=Only zbuffer is updated.
         3=Only RGB in framebuffer is updated.
  14     Destination alpha test enabled
  15     Destination alpha test method
         0=destination alpha bit == 0 passes
         1=destination alpha bit == 1 passes
  16     Depth test enabled (0 is prohibited?)
  17-18  Depth test method
         0=NEVER (all pixels fail)
         1=ALWAYS (all pixels pass)
         2=GEQUAL (pixel Z >= zbuffer Z passes)
         3=GREATER (pixel Z > zbuffer Z passes)
</TD></TR></TABLE>
Note on destination alpha test:<BR>
The alpha bit tested depends on the framebuffer format. If the format is PSMCT32, bit 7 of alpha is tested.
If the format is PSMCT16, the sole alpha bit is tested.
If the format is PSMCT24, all pixels pass due to the lack of alpha.<BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="vu"></A>&nbsp;
Vector Unit (VU)
</FONT></TD></TR></TABLE><BR>
The EE contains two Vector Units (VU0 and VU1), custom SIMD processors designed for fast floating-point manipulation.<BR>
Both VUs can run concurrently with the EE Core in micro mode. VU0 is also available in macro mode as COP2.<BR>
The architecture is similar to MIPS, including branch delays and the use of register zero as a constant.
<BR>
<A HREF="#vuregisters">VU Registers</A><BR>
<A HREF="#vuinstructionformat">VU Instruction Format</A><BR>
<A HREF="#vufmacpipeline">VU FMAC Pipeline</A><BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="vuregisters"></A>&nbsp;
VU Registers
</FONT></TD></TR></TABLE><BR>
<B>General-purpose registers</B><BR>
Each VU contains 32 vector floating-point registers (vf00-vf31) and 16 16-bit integer registers (vi00-vi15).<BR>
A vector register has 4 32-bit single-precision floating-point elements: {x, y, z, w}<BR>
vi00 is hardwired to 0. vf00 is hardwired to the vector {0.0, 0.0, 0.0, 1.0}. That is to say, vf00.w = 1.0.<BR>
<BR>
<B>Accumulator (ACC)</B><BR>
The accumulator is a special register with the same format as the 32 general-purpose vector registers.<BR>
It is intended to be used as an intermediate result by certain instructions.<BR>
<BR>
<B>Q and P</B><BR>
Q and P are 32-bit floating point registers.
Operations that use the FDIV or EFU units store their result in the Q and P registers respectively.<BR>
For example, a DIV stores its result in Q, and ESQRT stores its result in P.<BR>
<BR>
<B>MAC Flags</B><BR>
Each FMAC unit (corresponding to a vector field) has four MAC flags, which can be read by various instructions.<BR>
The MAC flags are overflow, underflow, sign, and zero. The full 16-bit MAC flag register has this format:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
15                                              0
-------------------------------------------------
|Ox|Oy|Oz|Ow|Ux|Uy|Uz|Uw|Sx|Sy|Sz|Sw|Zx|Zy|Zz|Zw|
-------------------------------------------------
</TD></TR></TABLE><BR>
Zero is set when the result is 0.0f or -0.0f (which also clears overflow and underflow), and 
sign is set when the result is negative (bit 31 is set).<BR>
Overflow and underflow are set when the exponent field is 0xFF or 0x0 respectively.<BR>
<B>IMPORTANT:</B> MAC flags are modified in the "writeback" stage in the FMAC pipeline.
However, an instruction like FMAND will read the flags in the register read stage, and this does not constitute a hazard.
<BR>This means every modification to the MAC flags has a delay of four cycles (not necessarily four instructions).<BR>
<BR>
<B>Clip Flags</B><BR>
The clipping flags register is 24-bit and contains the result of up to four CLIP instructions.
Every CLIP instruction produces six flags: -x, +x, -y, +y, -z, +z. They are stored in the following format:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
5                 0
-------------------
|-z|+z|-y|+y|-x|+x|
-------------------
</TD></TR></TABLE><BR>
Like the MAC flags, the clip flags are also pipelined (and thus delayed).<BR>
<BR>
<B>Status Flags</B><BR>
todo<BR>
<BR>
<BR>
 
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="eeintc"></A>&nbsp;
EE Interrupt Controller (INTC)
</FONT></TD></TR></TABLE><BR>
The EE has two separate interrupt signals: INT0 (raised by INTC) and INT1 (raised by DMAC).<BR>
<BR>
<B>1000F000h INTC_STAT - Interrupt status register (R=Status, W=Acknowledge)</B><BR>
<B>1000F010h INTC_MASK - Interrupt mask register (R/W)</B><BR>
Status: Read INTC_STAT (1=IRQ raised)<BR>
Acknowledge: Write INTC_STAT (0=No effect 1=Clear bit)<BR>
Mask: Write INTC_MASK (0=No effect, 1=Reverse)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     IRQ0   GS interrupt
  1     IRQ1   SBUS
  2     IRQ2   VBLANK start
  3     IRQ3   VBLANK end
  4     IRQ4   VIF0
  5     IRQ5   VIF1
  6     IRQ6   VU0
  7     IRQ7   VU1
  8     IRQ8   IPU
  9     IRQ9   Timer 0
  10    IRQ10  Timer 1
  11    IRQ11  Timer 2
  12    IRQ12  Timer 3
  13    IRQ13  SFIFO
  14    IRQ14  VU0 Watchdog
</TD></TR></TABLE><BR>
When (INTC_STAT & INTC_MASK), INT0 is asserted on COP0.Cause:8.
When COP0.Status:8 is true, an interrupt occurs, and the EE jumps to 80000200h.<BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="cdvd"></A>&nbsp;
CDVD Drive
</FONT></TD></TR></TABLE><BR>
Using the CDVD drive, the PS2 has the ability to read CDROMs, single-layer DVDs, and dual-layer DVDs.
It also sports backwards compatibility with the PSX's CDROM drive in PSX mode.<BR>
<BR>
CDVD commands are either asynchronous (N commands) or synchronous (S commands).
Seeks and reads fall into the former category, and miscellaneous commands, such as RTC access, fall into the latter.<BR>
<BR>
<B>CDVD Reference</B><BR>
<A HREF="#cdvdioports">CDVD I/O Ports</A><BR>
<A HREF="#cdvdncommands">CDVD N Commands</A><BR>
<A HREF="#cdvdreadsandseeks">CDVD Reads and Seeks</A><BR>
<A HREF="#cdvdscommands">CDVD S Commands</A><BR>
<BR>
<BR>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="cdvdioports"></A>&nbsp;
CDVD I/O Ports
</FONT></TD></TR></TABLE><BR>
<B>1F402004h Current N command (R/W)</B><BR>
Write to this register to send an N command. For a list of N commands, see<BR>
<A HREF="#cdvdncommands">CDVD N Commands</A><BR>
<BR>
<B>1F402005h N command status (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Unused
  1-3   Ready?
  4-5   Unused
  6     Ready
  7     Unused
</TD></TR></TABLE>
This shows if the CDVD drive is ready to receive an N command.
When bit 6 (0x40) is on, an N command can be sent.
Oddly, bits 1-3, when set, also seem to indicate ready status?<BR>
<BR>
<B>1F402005h N command param (W)</B><BR>
Send parameters for an N command here. This must be done BEFORE the N command has been sent via 1F402004h.<BR>
<BR>

<B>1F402006h CDVD error (R)</B><BR>
Any non-zero value indicates an error? Unknown what kind of errors are possible and what their values are.<BR>
<BR>
<B>1F402007h BREAK</B><BR>
Writing any value to this register sends a BREAK command to the CDVD drive, stopping execution of the current N command.<BR>
<BR>
<B>1F402008h CDVD I_STAT (R=Status, W=Acknowledge)</B><BR>
Status = Read I_STAT (1=Reason for IRQ)<BR>
Acknowledge = Write I_STAT (1=Clear bit)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Data ready?
  1     (N?) Command complete
  2     Power off pressed
  3     Disk ejected
  4     BS_Power DET?
  5-7   Unused
</TD></TR></TABLE>
When a CDVD IRQ is raised on I_STAT, this register shows the reason for the interrupt.
Bit 0 seems to be raised when a read command completes, but I'm not certain about this...<BR>
Unknown if bit 1 only applies to N commands, although this appears to be the case.<BR>
<BR>
<B>1F40200Ah CDVD drive status (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h  Stopped
  02h  Spinning
  06h  Reading
  0Ah  Paused
</TD></TR></TABLE>
<BR>
<B>1F40200Fh CDVD disk type (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h  None?
  12h  CDROM
  14h  DVD
  Unknown what other types are possible.
</TD></TR></TABLE>
<B>1F402016h Current S command (R/W)</B><BR>
Write to this register to send an S command. For a list of S commands, see<BR>
<A HREF="#cdvdscommands">CDVD S Commands</A><BR>
<BR>
<B>1F402017h S command status (R)</B><BR>
40h indicates that the CDVD drive can receive an S command. 00h means that it is busy.<BR>
<BR>
<B>1F402018h S command result (R)</B><BR>
When an S command has finished executing, read the result here. Some S commands may require multiple reads.<BR>
<BR>
<B>1F402018h S command params (W)</B><BR>
Parameters must be sent BEFORE the S command is sent.<BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="cdvdncommands"></A>&nbsp;
CDVD N Commands
</FONT></TD></TR></TABLE><BR>
Parameters are in units of bytes and are little-endian. All N commands raise IRQ2 (bit 1 of CDVD I_STAT).<BR><BR>
<B>00h NOP</B><BR>
<B>01h NOPsync</B><BR>
Params: None.<BR>
These commands do nothing? They do raise an IRQ upon their "completion".<BR>
<BR>
<B>02h Standby</B><BR>
Params: None.<BR>
Returns the read position to sector 0 and sets the drive status to PAUSED.<BR>
Possibly also spins the drive if it's not spinning already?<BR>
<BR>
<B>03h Stop</B><BR>
Params: None.<BR>
Returns the read position to sector 0, sets the drive status to STOPPED, and stops the drive from spinning.<BR>
Seems to have a 166 ms delay?<BR>
<BR>
<B>04h Pause</B><BR>
Params: None.<BR>
Unknown what effect this has, from the perspective of emulation.<BR>
<BR>
<B>05h Seek</B><BR>
Params:
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   Sector position
</TD></TR></TABLE>
Moves the read position to the indicated parameter.<BR>
<BR>
<B>06h ReadCd</B><BR>
Params:
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   Sector position
  4-7   Sectors to read
  10    Block size (1=2328 bytes, 2=2340 bytes, all others=2048 bytes)
</TD></TR></TABLE>
Performs a CD-style read. Seems to raise bit 0 of CDVD I_STAT upon completion?<BR>
<BR>
<B>08h ReadDvd</B><BR>
Params:
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   Sector position
  4-7   Sectors to read
</TD></TR></TABLE>
Performs a DVD-style read, with a block size of 2064 bytes. The format of the data is as follows:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    1    Volume number + 0x20
  1    3    Sector number - volume start + 0x30000, in big-endian.
  4    8    ? (all zeroes)
  12   2048 Raw sector data
  2060 4    ? (all zeroes)
</TD></TR></TABLE><BR>

<B>09h GetToc</B><BR>
Params: None?
Fetches the ToC from the disk, with a block size of 2064 bytes.<BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="cdvdreadsandseeks"></A>&nbsp;
CDVD Reads and Seeks
</FONT></TD></TR></TABLE><BR>
<B>Seeking</B><BR>
If a read command is called, a seek must be performed.
An IRQ is NOT raised when the seek finishes during a read command.<BR>
When a seek begins, if the drive is currently not spinning, it takes 333 ms for the drive to spin and finish the seek.<BR>
Otherwise, one of three seek modes is possible:<BR>
- Contiguous read: When the seek delta is very small or zero, seek time = block_timing * delta<BR>
- Fast seek: When seek delta < 14764 for DVD reads and < 4371 for CD reads, seek time = ~30 ms<BR>
- Full seek: Seek time = ~100 ms<BR>
block_timing (in IOP cycles) can be found by the following formula:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  block_timing = (IOP_CLOCK * block_size) / read_speed
</TD></TR></TABLE>
Where IOP_CLOCK is ~36,864,000 Hz.
read_speed for CD reads is 24 * 153600. For DVD reads read_speed = 4 * 1382400.<BR>
Unknown what delta is needed for a contiguous read (8/16 is used for CD/DVD respectively in PCSX2).<BR>
<BR>
<B>Reads</B><BR>
The time needed to read a single sector is the block_timing formula above.
Once one sector has been read, the CDVD DMA channel can store the data in memory
and allow the CDVD drive to continue.<BR>
When all sectors have been read, a CDVD IRQ is raised. Successful reads seem to raise both bits 1 AND 0 of CDVD I_STAT?<BR>
<BR>
<BR>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="cdvdscommands"></A>&nbsp;
CDVD S Commands
</FONT></TD></TR></TABLE><BR>
The results of an S command can be read one at a time from 1F402017. All units are in bytes.<BR>
<BR>
<B>08h ReadRTC</B><BR>
Params: None.
Result:
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Zero
  1     Second
  2     Minute
  3     Hour
  4     Zero
  5     Day
  6     Month
  7     Year
</TD></TR></TABLE>
Returns the current time stored on the RTC, in BCD format.<BR>
The RTC is mostly just used by the BIOS.
Notably, Metal Gear Solid 3 requires the RTC to boot. This is likely an anti-piracy feature.<BR>
<BR>
<B>09h WriteRTC</B><BR>
Params:
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Ignored
  1     Second
  2     Minute
  3     Hour
  4     Ignored
  5     Day
  6     Month
  7     Year
</TD></TR></TABLE>
Overwrites the RTC's time in BCD format.<BR>
<BR>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="iopint"></A>&nbsp;
IOP Interrupts
</FONT></TD></TR></TABLE><BR>
Interrupt handling for the IOP is similar to its PSX counterpart.
The main differences are an additional register (I_CTRL) and more interrupt lines.<BR>
<BR>
<B>1F801070h I_STAT - Interrupt status register (R=Status, W=Acknowledge)</B><BR>
<B>1F801074h I_MASK - Interrupt mask register (R/W)</B><BR>
Status: Read I_STAT (1=IRQ raised)<BR>
Acknowledge: Write I_STAT (0=Clear bit 1=No effect)<BR>
Mask: Read/Write I_MASK (0=Disabled 1=Enabled)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     IRQ0   VBLANK start
  1     IRQ1   GPU (used in PSX mode)
  2     IRQ2   CDVD Drive
  3     IRQ3   DMA
  4     IRQ4   Timer 0
  5     IRQ5   Timer 1
  6     IRQ6   Timer 2
  7     IRQ7   SIO0
  8     IRQ8   SIO1
  9     IRQ9   SPU2
  10    IRQ10  PIO
  11    IRQ11  VBLANK end
  12    IRQ12  DVD? (unknown purpose)
  13    IRQ13  PCMCIA (related to DEV9 expansion slot)
  14    IRQ14  Timer 3
  15    IRQ15  Timer 4
  16    IRQ16  Timer 5
  17    IRQ17  SIO2
  18    IRQ18  HTR0? (unknown purpose)
  19    IRQ19  HTR1?
  20    IRQ20  HTR2?
  21    IRQ21  HTR3?
  22    IRQ22  USB
  23    IRQ23  EXTR? (unknown purpose)
  24    IRQ24  FWRE (related to FireWire)
  25    IRQ25  FDMA? (FireWire DMA?)
  26-31 Unused/garbage
</TD></TR></TABLE><BR>
<B>1F801078h I_CTRL - Global interrupt control (R=Status and Disable, W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Disable all interrupts
  1-31  Unused/garbage
</TD></TR></TABLE>
When bit 0=1, all IOP interrupts are disabled.
Reading this register returns bit 0 AND clears it, re-enabling interrupts.
Writing can set or reset bit 0.<br>
NOTE: There seems to be a 4 cycle delay when re-enabling interrupts via this register.<BR>
<BR>
<B>Raising Interrupts</B><BR>
If !I_CTRL && (I_STAT & I_MASK), then COP0.Cause:8 is set. When COP0.Status:8 is also set when this occurs,
COP0.Cause.Excode is set to 00h and the IOP jumps to 80000080h, where the interrupt will be processed.<BR>
<BR>
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="ioptimers"></A>&nbsp;
IOP Timers
</FONT></TD></TR></TABLE><BR>
<B>1F801100h+N*10h Timer 0..2 count (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Current value
  16-31 Unused/garbage
</TD></TR></TABLE>
<B>1F801480h+(N-3)*10h Timer 3..5 count (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Current value
</TD></TR></TABLE>
Timers 0..5 increment automatically. 0..2 are 16-bit, and 3..5 are 32-bit.
Writes set the counter to the value written.<BR>
<BR>
<B>1F801104h+N*10h Timer 0..2 mode (R/W)</B><BR>
<B>1F801484h+(N-3)*10h Timer 3..5 mode (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Gate enable
  1-2   Gate mode
  3     Zero return - reset counter on interrupt
  4     Compare interrupt enabled
  5     Overflow interrupt enabled
  6     Repeat interrupt - if unset, bit 10 is set to 0 after interrupt occurs.
  7     LEVL - toggle bit 10 on IRQs if bit 6 is set.
  8     Use external signal
        If set:
          Timer 0: pixel clock (13.5 MHz regardless of screen mode)
          Timer 1/3: HBLANK
          Others: sysclock (no effect)
  9     Timer 2 prescaler
  10    Interrupts enabled (R)
  11    Compare interrupt raised (R)
  12    Overflow interrupt raised (R)
  13-14 Timer 4/5 prescalar
  15-31 Unused/garbage
</TD></TR></TABLE>
Writes to mode reset the count to zero and set bit 10 to 1.
Reads from mode clear the two raised interrupt flags.<BR>
Prescalers adjust clockrate as follows:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     normal
  1     1/8 speed
  2     1/16 speed
  3     1/256 speed
</TD></TR></TABLE><BR>
<B>1F801108h+N*10h Timer 0..2 target (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Value
  16-31 Unused/garbage
</TD></TR></TABLE>
<B>1F801488h+(N-3)*10h Timer 3..5 target (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Value
</TD></TR></TABLE>
When count == target, a compare interrupt is raised.
This raises an IRQ in I_STAT if both mode.4 and mode.10 are enabled.<BR>
If mode.7 (LEVL) is not set, writes to target set mode.10 to 1.<BR>
<BR>
<BR>
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="bios"></A>&nbsp;
BIOS
</FONT></TD></TR></TABLE><BR>
The PS2 BIOS resides in a 4 MB ROM.
Its purpose is to initialize hardware into a usable state,
provide EE services and IOP modules, and launch PS2/PSX games.<BR>
<BR>
<B>BIOS Reference</B><BR>
<A HREF="#biosfilestructure">BIOS File Structure</A><BR>
<A HREF="#biosbootprocess">BIOS Boot Process</A><BR>
<A HREF="#bioseethreading">BIOS EE Threading</A><BR>
<A HREF="#bioseesyscalls">BIOS EE Syscalls</A><BR>
<BR>
<B>BIOS IOP Modules</B><BR>
Unlike the EE, the IOP does not have a monolithic kernel. 
Instead, the kernel and device drivers are split into many modules.<BR>
These modules are represented as IRX files, which are custom relocatable ELFs.<BR>
<BR>
<A HREF="#biosiopmodulelinking">BIOS IOP Module Linking</A><BR>
<A HREF="#biosiopsysmem">BIOS IOP SYSMEM - Memory Management</A><BR>
<A HREF="#biosioploadcore">BIOS IOP LOADCORE - Kernel Loader and Linker</A><BR>
<A HREF="#biosiopexcepman">BIOS IOP EXCEPMAN - Exception Manager</A><BR>
<A HREF="#biosiopintrman">BIOS IOP INTRMAN - Interrupt Manager</A><BR>
<A HREF="#biosiopssbusc">BIOS IOP SSBUSC - Subsystem Bus Controller</A><BR>
<A HREF="#biosiopdmacman">BIOS IOP DMACMAN - DMAC Manager</A><BR>
<BR>
<BR>
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="biosfilestructure"></A>&nbsp;
BIOS File Structure
</FONT></TD></TR></TABLE><BR>
The BIOS consists of dozens of separate files. These files are indexed and accessed through ROMDIR.<BR>
Each ROMDIR entry has the following format.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  struct romdir_entry
  {
    char name[10]; //File name, must be null terminated
    ushort ext_info_size; //Size of the file's extended info in EXTINFO
    uint file_size; //Size of the file itself
  }
</TD></TR></TABLE>
First four entries in an SCPH-39001 ROMDIR:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0x00002740: 52455345 54000000 00000C00 40270000      RESET
  0x00002750: 524F4D44 49520000 00005400 D0050000      ROMDIR
  0x00002760: 45585449 4E464F00 00000000 80070000      EXTINFO
  0x00002770: 524F4D56 45520000 00000000 10000000      ROMVER
  ...
</TD></TR></TABLE>
To find the start of ROMDIR, look for the first occurrence of "RESET" in the BIOS.<BR>
To find a specific file in the BIOS, find its entry in ROMDIR and then add the file sizes of all previous files to get the 
starting address.<BR>
<BR>
<BR>
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="biosbootprocess"></A>&nbsp;
BIOS Boot Process
</FONT></TD></TR></TABLE><BR>
Upon reset, both the EE and IOP begin executing at BFC00000h.
The BIOS checks which CPU is executing by checking COP0.PRid (register 15).
If PRid >= 59h, the EE boot code is executed. Else, the IOP boot code is executed.<BR>
<BR>
<B>EE boot process</B><BR>
- The EE clock speed is measured. (SCPH-10000 uses COP0.Count; SCPH-39001 counts HBLANKs using one of the timers.
Unknown what other BIOSes use.)<BR>
- The memory controller is initialized, giving access to the 32 MB of RDRAM.<BR>
- The EE kernel is copied into RAM starting at virtual address 80000000h.
The BIOS jumps to the entry point at 80001000h.<BR>
- The TLB and PGIF handler are initialized and various hardware components are reset.<BR>
- EENULL, an idle loop thread, is loaded into 00081FC0h.<BR>
- SIF DMA is initialized. The EE writes to an SIF register and waits for a reply from the IOP.<BR>
- The EELOAD module is loaded, which in turn loads OSDSYS.<BR>
<BR>
OSDSYS, once loaded, is responsible for bringing up the "Sony Computer Entertainment" screen and the browser.<BR>
<BR>
<B>IOP boot process</B><BR>
- Various hardware registers are initialized, and IOPBOOT is loaded.<BR>
- IOPBOOT finds SYSMEM and LOADCORE, loads them into memory, and executes their entry points.<BR>
- LOADCORE boots all of the IOP modules in the BIOS, starting with EXCEPMAN.<BR>
- At some point, SIF is initialized. The IOP waits for the EE to send a message and replies over another SIF register.<BR>
- Once all modules have been loaded, the IOP enters an infinite loop, waiting for the EE to send commands.<BR>
<BR>
<BR>
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="bioseethreading"></A>&nbsp;
BIOS EE Threading
</FONT></TD></TR></TABLE><BR>
The EE kernel uses a cooperative priority-based thread scheduler.
It can support up to 256 threads and 256 semaphores. 128 priority levels are available.<BR>
<BR>
<B>Structs</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  struct ThreadParam //Used as argument for CreateThread, ReferThreadStatus
  {
    int status;
    void *func; //function to execute when thread begins
    void *stack;
    int stack_size;
    void *gp_reg;
    int initial_priority;
    int current_priority;
    u32 attr;
    u32 option;
  }
</TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  struct SemaParam //Used as argument for CreateSema
  {
    int count, //used by WaitSema and SignalSema
	      max_count,
	      init_count, //initial value for count
	      wait_threads; //number of threads associated with this semaphore
	  u32 attr, //not used by kernel
	      option; //not used by kernel
  }
</TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  //Thread statuses
  #define THS_RUN 0x01
  #define THS_READY 0x02
  #define THS_WAIT 0x04
  #define THS_SUSPEND 0x08
  #define THS_WAITSUSPEND 0x0C //THS_WAIT | THS_SUSPEND
  #define THS_DORMANT 0x10
  struct TCB //Internal thread structure
  {
    struct TCB *prev;
    struct TCB *next;
    int status;
    void *func;
    void *current_stack;
    void *gp_reg;
    short current_priority;
    short init_priority;
    int wait_type; //0=not waiting, 1=sleeping, 2=waiting on semaphore
    int sema_id;
    int wakeup_count;
    int attr;
    int option;
    void *_func; //???
    int argc;
    char **argv;
    void *initial_stack;
    int stack_size;
    int *root; //function to return to when exiting thread?
    void *heap_base;
  }
</TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  struct sema //Internal semaphore structure
  {
    struct sema *free; //pointer to empty slot for a new semaphore
    int count;
    int max_count;
    int attr;
    int option;
    int wait_threads;
    struct TCB *wait_next, *wait_prev;
  }
</TD></TR></TABLE><BR>

<B>Thread Scheduler</B><BR>
The kernel uses an array of 128 doubly-linked lists for managing thread priorities.
The general algorithm for the scheduler is as follows:
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  void reschedule(uint32 EPC, uint32 stack)
    Set current thread entry function to EPC (instruction after exception)
    Set current thread stack base to stack
    Set current thread status to READY
    Loop through active thread priority list, starting from 0 (highest priority)
      If an active thread is found, set current thread to it and break
      If no active thread is found, print an error and call Exit(1)
    Set found thread's status to RUN and return its entry function and stack pointer
</TD></TR></TABLE>
Scheduling is only invoked by syscalls and relies on absolute priority.
Threads with lower priority will never run as long as there is an active thread with higher priority.<BR>
<BR>
<B>Semaphores</B><BR>
Threads that call WaitSema on a semaphore with a "count" of zero are placed in a WAIT state
and removed from the active thread list.<BR>
Conversely, calling SignalSema re-adds a thread waiting on a semaphore to the active list.<BR>
Semaphores are useful for blocking execution of a thread until a task completes.
Sony's official SIF protocol, for instance, use a semaphore to place the caller thread to sleep 
while the IOP processes a request.
The caller thread is reactivated in the SIF interrupt handler.<BR>
<BR>
<BR>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="bioseesyscalls"></A>&nbsp;
BIOS EE Syscalls
</FONT></TD></TR></TABLE><BR>
When a SYSCALL instruction is executed, the EE jumps to 80000180h and sets COP0.Cause to 08h.
The kernel syscall handler retrieves the syscall number from the v1 register.<BR>
Negative syscalls use the current thread's stack for internal operations and are meant to be used in interrupt handlers.
Positive syscalls use the kernel stack, and some of them can trigger thread reschedules.
<BR>
<BR>
<B>List of EE Syscalls</B><BR>
<B>01h void ResetEE(int reset_flag)</B><BR>
Resets EE components depending on which bits are set in reset_flag:
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0 - DMAC
  1 - VU1
  2 - VIF1
  3 - GIF
  4 - VU0
  5 - VIF0
  6 - IPU
</TD></TR></TABLE>
NOTE: INTC is reset regardless of the flag's settings.<BR>
<BR>
<B>02h void SetGsCrt(bool interlaced, int display_mode, bool frame)</B><BR>
Initializes the PCRTC.<BR>
<BR>
<B>04h void Exit(int status)</B><BR>
Returns to the OSDSYS browser. Internally calls LoadExecPS2("rom0:OSDSYS", 1, "BootBrowser").<BR>
<BR>
<B>05h void _ExceptionEpilogue/RFU005()</B><BR>
Internal syscall used by kernel exception handlers. Returns to the user program.<BR>
<BR>
<B>06h void LoadExecPS2(const char* filename, int argc, char** argv)</B><BR>
Loads an ELF with the specified arguments and executes it.
This function also clears all of the internal kernel state, such as threads and semaphores, before execution.<BR>
This function does not (and must not) return.<BR>
<BR>
<B>07h void ExecPS2(void* entry, void* gp, int argc, char** argv)</B><BR>
Clears all of the internal kernel state and creates a thread with priority 0 (main thread).
The thread begins executing from the entry point.<BR>
This function does not (and must not) return.<BR>
<BR>
<B>10h int AddIntcHandler(int int_cause, int (*handler)(int), int next, void* arg, int flag)</B><BR>
Adds an interrupt handler with the specified cause to a queue.
This function returns the id of the handler or -1 if the operation fails.
int_cause corresponds to a bit in INTC_STAT/INTC_MASK. For example, int_cause=2 will register a VBLANK handler.<BR>
next is a previously registered handler id which this handler will be placed before.
next==0 will place the handler in front of the queue, and next==-1 will place it at the back of the queue.<BR>
arg and flag are stored in the handler struct but don't seem to be used otherwise?<BR>
<BR>
<B>11h int RemoveIntcHandler(int int_cause, int handler_id)</B><BR>
Removes the handler associated with the interrupt cause. Returns -1 if the operation fails.<BR>
<BR>
<B>12h int AddDmacHandler(int dma_cause, int (*handler)(int), int next, void* arg, int flag)</B><BR>
Adds an interrupt handler for INT1 (DMAC) interrupts. Otherwise works the same as AddIntcHandler.<BR>
<BR>
<B>13h int RemoveDmacHandler(int dma_cause, int handler_id)</B><BR>
Works same as RemoveIntcHandler.<BR>
<BR>
<B>14h bool _EnableIntc(int cause_bit)</B><BR>
Enables the indicated bit in INTC_MASK. Returns true if this bit was set to 0 and false if it was already set to 1.<BR>
<BR>
<B>15h bool _DisableIntc(int cause_bit)</B><BR>
Disables the indicated bit in INTC_MASK. Returns true if this bit was set to 1 and false if it was already set to 0.<BR>
<BR>
<B>16h bool _EnableDmac(int cause_bit)</B><BR>
Same as _EnableIntc, but for D_STAT's mask.<BR>
<BR>
<B>17h bool _DisableDmac(int cause_bit)</B><BR>
Same as _DisableIntc, but for D_STAT's mask.<BR>
<BR>
<B>20h int CreateThread(ThreadParam* t)</B><BR>
Creates a thread with DORMANT status. The thread is not placed in the priority linked-list.<BR>
Only t->func, t->initial_priority, t->stack, t->stack_size, and t->gp_reg are used.
The new thread re-uses the heap of its parent thread.<BR>
Returns the id of the newly created thread, or -1 if the function fails.<BR>
<BR>
<B>21h void DeleteThread(int thread_id)</B><BR>
Deletes a thread. The function only succeeds if the thread has DORMANT status and is not the current thread.<BR>
<BR>
<B>22h void StartThread(int thread_id, void* arg)</B><BR>
Adds a DORMANT thread to the active thread list and gives it READY status, forcing a thread reschedule.
arg is intended to be used by the callee thread if it becomes the current thread.<BR>
The function fails if the thread is the current thread or is not DORMANT.<BR>
<BR>
<B>23h void ExitThread()</B><BR>
Removes the current thread from the active thread list, resets it, and gives it DORMANT status,
forcing a thread reschedule.<BR>
<BR>
<B>24h void ExitDeleteThread()</B><BR>
Deletes the current thread, forcing a thread reschedule.<BR>
<BR>
<B>25h void TerminateThread(int thread_id)</B><BR>
Has different behavior depending on the thread's status:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  No status (0), RUN, DORMANT - No effect.
  READY - Removes thread from active thread list, resets it, and gives it DORMANT status, forcing a thread reschedule.
  WAIT, WAITSUSPEND - Same as READY but also decrements the thread's semaphore's "wait_threads" by one.
  All other statuses - Resets the thread and gives the thread DORMANT status, forcing a thread reschedule.
</TD></TR></TABLE>
<BR>
<B>26h void iTerminateThread(int thread_id)</B><BR>
Same as TerminateThread, but does not force a thread reschedule. Used internally by TerminateThread.<BR>
Returns -1 if unsuccessful.<BR>
<BR>
<B>29h void ChangeThreadPriority(int thread_id, int priority)</B><BR>
Changes the thread's priority, forcing a thread reschedule. If thread_id==0, the current thread's id is used.<BR>
This function fails if the thread is DORMANT.<BR>
<BR>
<B>2Ah int iChangeThreadPriority(int thread_id, int priority)</B><BR>
Same as ChangeThreadPriority, but does not force a thread reschedule. Used internally by ChangeThreadPriority.<BR>
Returns -1 upon a failure.<BR>
<BR>
<B>2Bh void RotateThreadReadyQueue(int priority)</B><BR>
<BR>
<B>2Ch int _iRotateThreadReadyQueue(int priority)</B><BR>
<BR>
<B>2Dh void ReleaseWaitThread(int thread_id)</B><BR>
If the thread has WAIT status, it is given READY status and added to the active thread list.
If it has WAITSUSPEND status, it is given SUSPEND status.<BR>
Both (and only) these cases force a thread reschedule. The reference to the thread's semaphore is also removed.<BR>
<BR>
<B>2Eh int iReleaseWaitThread(int thread_id)</B><BR>
Same as ReleaseWaitThread, but does not force a thread reschedule. Internally used by ReleaseWaitThread.<BR>
Returns -1 if unsuccessful.<BR>
<BR>
<B>2Fh int GetThreadId()</B><BR>
Returns the current thread's id.<BR>
<BR>
<B>30h int ReferThreadStatus(int thread_id, ThreadParam* status)</B><BR>
<B>31h int iReferThreadStatus(int thread_id, ThreadParam* status)</B><BR>
Fills out the ThreadParam struct with the given thread's information. Returns -1 if unsuccessful.<BR>
The "i" variant performs exactly the same function.<BR>
<BR>
<B>32h void SleepThread()</B><BR>
If the current thread's "wakeup_count" is greater than zero, it is decremented.
Else, if the thread status is RUN or READY, the current thread is removed from the active thread list and set to WAIT, 
	forcing a thread reschedule.<BR>
<BR>
<B>33h void WakeupThread(int thread_id)</B><BR>
Has different behavior depending on the thread's status:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  WAIT (sleeping) - Set to READY and re-added to active thread list, forcing a thread reschedule.
  WAITSUSPEND (sleeping) - Placed in SUSPEND status, forcing a thread reschedule.
  READY, SUSPEND, WAIT/WAITSUSPEND (semaphore) - Increments "wakeup_count", forcing a thread reschedule.
  Other statuses - No effect.
</TD></TR></TABLE><BR>
<B>34h int iWakeupThread(int thread_id)</B><BR>
Same as WakeupThread, but does not force a thread reschedule. Internally used by WakeupThread.<BR>
Returns -1 if unsuccessful.<BR>
<BR>
<B>35h int CancelWakeupThread(int thread_id)</B><BR>
<B>36h int iCancelWakeupThread(int thread_id)</B><BR>
Resets the thread's "wakeup_count" to zero. Returns -1 if unsuccessful, or the old wakeup_count otherwise.<BR>
<BR>
<B>37h int SuspendThread(int thread_id)</B><BR>
<B>38h int iSuspendThread(int thread_id)</B><BR>
Has different behavior depending on the thread's status:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  READY, RUN - Removed from active thread list and placed in SUSPEND status.
  WAIT - Placed in WAITSUSPEND status.
  All other statuses - No effect.
</TD></TR></TABLE>
Returns -1 on failure or thread_id otherwise.<BR>
BUG: This function does NOT force a thread reschedule! If the current thread is suspended, it will continue to run!<BR>
<BR>
<B>39h void ResumeThread(int thread_id)</B><BR>
Has different behavior depending on the thread's status:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  SUSPEND - Placed in READY or RUN status and added to active thread list, forcing a thread reschedule.
  WAITSUSPEND - Placed in WAIT status, forcing a thread reschedule.
  All other statuses - No effect
</TD></TR></TABLE><BR>
<B>3Ah int iResumeThread(int thread_id)</B><BR>
Same as ResumeThread, but does not force a thread reschedule. Internally used by ResumeThread.<BR>
Returns -1 if unsuccessful or thread_id otherwise.<BR>
<BR>
<B>3Bh void JoinThread()</B><BR>
<BR>
<B>3Ch void* InitMainThread/RFU060(uint32 gp, void* stack, int stack_size, char* args, int root)</B><BR>
Initializes the current thread. Returns the stack pointer of the thread.<BR>
If stack == -1, the stack pointer equals the end of RDRAM - stack_size. Else, it equals stack + stack_size.<BR>
This function should only be called before the program's main function.<BR>
<BR>
<B>3Dh void* InitHeap/RFU061(void* heap, int heap_size)</B><BR>
Initializes the current thread's heap. If heap == -1, the end of the heap resides at the thread's stack pointer.
Else, the end of the heap is heap + heap_size.<BR>
Returns the end of the thread's heap.<BR>
<BR>
<B>3Eh void* EndOfHeap()</B><BR>
Returns the current thread's heap base.<BR>
<BR>
<B>40h int CreateSema(SemaParam* s)</B><BR>
Creates a semaphore. Returns the semaphore's id if successful and -1 if not.<BR>
Only s->init_count and s->max_count need to be specified. s->attr and s->option may also be specified.<BR>
<BR>
<B>41h int DeleteSema(int sema_id)</B><BR>
Deletes the semaphore, forcing a thread reschedule.
Threads waiting on the semaphore will either be released or suspended, depending on their status.<BR>
<BR>
<B>42h int SignalSema(int sema_id)</B><BR>
Signals a semaphore. If a thread has called WaitSema on this semaphore, this forces a thread rescheduling.
Otherwise, the semaphore's count is incremented by one.<BR>
Returns -1 if unsuccessful.<BR>
<BR>
<B>43h int iSignalSema(int sema_id)</B><BR>
Similar to SignalSema, except this does not reschedule threads.
The semaphore's threads are simply re-added to the active thread list.<BR>
This function is called internally by SignalSema.
Returns -1 if unsuccessful and -2 if the thread is released from its wait state.<BR>
<BR>
<B>44h void WaitSema(int sema_id)</B><BR>
If the semaphore's "count" variable > 0, count is decremented. 
Else, a thread rescheduling occurs, changing the active thread. The caller thread's status is set to WAIT.<BR>
<BR>
<B>45h int PollSema(int sema_id)</B><BR>
<B>46h int iPollSema(int sema_id)</B><BR>
Decrements the semaphore's count variable. Returns -1 if unsuccessful.<BR>
<BR>
<B>64h void FlushCache(int mode)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Modes of operation
  mode=0: Flush data cache (invalidate+writeback dirty contents to memory)
  mode=1: Invalidate data cache
  mode=2: Invalidate instruction cache
  All other modes invalidate both caches.
</TD></TR></TABLE><BR>
<B>70h uint64_t GsGetIMR()</B><BR>
Returns the value of the privileged register GS_IMR.<BR>
<BR>
<B>71h void GsPutIMR(uint64_t value)</B><BR>
Sets GS_IMR to the value.<BR>
<BR>
<B>74h void SetSyscall/RFU116(int index, int address)</B><BR>
Replaces an entry on the syscall table with the specified address.<BR>
This function does not perform any bounds checking.<BR>
<BR>
<B>76h int SifDmaStat(unsigned int dma_id)</B><BR>
Returns a positive value if the SIF transfer is queued, 0 if the transfer is in progress, and a negative value 
if the transfer has completed.<BR>
<BR>
<B>77h unsigned int SifSetDma(SifDmaTransfer* trans, int len)</B><BR>
Low-level syscall for starting SIF1 transfers. The format of SifDmaTransfer is as follows.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  struct SifDmaTransfer //Internal semaphore structure
  {
    void* src; //EE source
    void* dest; //IOP destination
    int size; //Size in bytes
    int attr;
  }
</TD></TR></TABLE>
The len parameter is how large the SifDmaTransfer array is. Multiple SIF1 transfers are queued by the kernel.<BR>
This function returns the ID of the current transfer. It does not wait for the transfer to complete.<BR>
<BR>
<B>78h void SifSetDChain()</B><BR>
Initializes the SIF0 channel by resetting QWC and setting CHCR to 184h 
(channel busy, chain mode, TTE bit in tag enabled).<BR>
<BR>
<B>7Bh void ExecOSD(int argc, char** argv)</B><BR>
Shorthand for LoadExecPS2("rom0:OSDSYS", argc, argv).<BR>
<BR>
<B>7Dh void PSMode()</B><BR>
<BR>
<B>7Eh int MachineType()</B><BR>
<BR>
<B>7Fh int GetMemorySize()</B><BR>
Returns the amount of RDRAM on the console in bytes.<BR>
<BR>
<BR>
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="biosiopmodulelinking"></A>&nbsp;
BIOS IOP Module Linking
</FONT></TD></TR></TABLE><BR>
IOP modules are dynamically linked to each other, but Sony devised an ingenious way to handle this without exposing symbols.
<BR>
Linking is accomplished through export tables and import tables. A module can have multiple export tables, which define
the functions other modules may access. Import tables give a module access to another module's export table.<BR>
<BR>
The format of an export table is as follows.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  struct export_table
  {
    uint magic; //Must equal 0x41C00000!
    export_table* next; //Internal data for LOADCORE
    ushort version; //0x101 would be version 1.01
    ushort mode; //Unknown what this does
    char name[8]; //Name of the module. Must include a NULL terminator.
    void* export[0]; //An arbitrarily sized array of function pointers. 
  }
</TD></TR></TABLE>
The format of a import table is similar.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  struct import_table
  {
    uint magic; //Must equal 0x41E00000!
    import_table* next; //Internal data for LOADCORE
    ushort version;
    ushort mode;
    char name[8];
    void* import[0]; //An arbitrarily sized array of jr ra; addiu zero, zero, X instruction pairs. More on that below.
  }
</TD></TR></TABLE>
LOADCORE is responsible for linking modules to each other. When a new module is loaded, LOADCORE parses its import tables. 
When an import table matches an export table, it looks up functions by taking X from addiu zero, zero, X, which is 
used as an index in the export's function pointer array. Each jr ra is then replaced with j $function. In other words, 
the return statement is replaced with a direct jump to an imported module's function.<BR>
<BR>
Since functions are only linked by their IDs, rather than their names, in theory this keeps others from learning the 
names of the functions. In practice, game developers often created custom IOP modules which they forgot to strip, which is 
how the symbols in Sony's IOP modules are known.<BR>
<BR>
<BR>
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="biosiopsysmem"></A>&nbsp;
BIOS IOP SYSMEM - Memory Management
</FONT></TD></TR></TABLE><BR>
<B>Exports</B><BR>
<B>04h void* AllocSysMemory(int mode, int size, void* ptr)</B><BR>
<BR>
<B>05h int FreeSysMemory(void* ptr)</B><BR>
<BR>
<B>06h uint QueryMemSize()</B><BR>
<BR>
<B>07h uint QueryMaxFreeMemSize()</B><BR>
<BR>
<B>08h uint QueryTotalFreeMemSize()</B><BR>
<BR>
<B>09h void* QueryBlockTopAddress(void* addr)</B><BR>
<BR>
<B>0Ah int QueryBlockSize(void* addr)</B><BR>
<BR>
<B>0Dh int Kprintf(const char* format,...)</B><BR>
<BR>
<B>0Eh void KprintfSet(KprintfHandler* handler, void* context)</B><BR>
<BR>
<BR>
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="biosioploadcore"></A>&nbsp;
BIOS IOP LOADCORE - Kernel Loader and Linker
</FONT></TD></TR></TABLE><BR>
<B>Exports</B><BR>
<B>04h void FlushIcache()</B><BR>
<BR>
<B>05h void FlushDcache()</B><BR>
<BR>
<B>06h int RegisterLibraryEntries(export_table* t)</B><BR>
<BR>
<B>07h int ReleaseLibraryEntries(export_table* t)</B><BR>
<BR>
<B>0Ah int RegisterNonAutoLinkEntries(export_table* t)</B><BR>
<BR>
<B>0Bh void* QueryLibraryEntryTable(iop_library* library)</B><BR>
<BR>
<B>0Ch int* QueryBootMode(int mode)</B><BR>
<BR>
<B>0Dh void RegisterBootMode(boot_mode* b)</B><BR>
<BR>
<B>14h int RegisterPostBootCallback(BootupCallback func, int priority, int *stat)</B><BR>
<BR>
<BR>
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="biosiopexcepman"></A>&nbsp;
BIOS IOP EXCEPMAN - Exception Manager
</FONT></TD></TR></TABLE><BR>
EXCEPMAN installs exception vectors at RAM addresses 0x40 and 0x80, but they do not do anything useful by themselves. 
Other modules will use EXCEPMAN to install their own handlers.<BR>
<BR>
<B>Exports</B><BR>
<B>04h RegisterExceptionHandler(int exception, ExceptionHandler handler)</B><BR>
Alias for RegisterPriorityExceptionHandler(exception, 2, handler).<BR>
<BR>
<B>05h RegisterPriorityExceptionHandler(int exception, int priority, ExceptionHandler handler)</B><BR>
<BR>
<B>06h RegisterDefaultExceptionHandler(ExceptionHandler handler)</B><BR>
<BR>
<B>07h ReleaseExceptionHandler(int exception, ExceptionHandler handler)</B><BR>
<BR>
<B>08h ReleaseDefaultExceptionHandler(ExceptionHandler handler)</B><BR>
<BR>
<BR>
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="biosiopintrman"></A>&nbsp;
BIOS IOP INTRMAN - Interrupt Manager
</FONT></TD></TR></TABLE><BR>
INTRMAN installs the default interrupt and syscall vectors, though like EXCEPMAN, it is up to other modules to install 
useful handlers.<BR>
<BR>
<B>Exports</B><BR>
<B>04h int RegisterIntrHandler(int irq, int mode, int (*handler)(void *), void *arg)</B><BR>
<BR>
<B>05h int ReleaseIntrHandler(int irq)</B><BR>
<BR>
<B>06h int EnableIntr(int irq)</B><BR>
<BR>
<B>07h int DisableIntr(int irq)</B><BR>
<BR>
<B>08h int CpuDisableIntr()</B><BR>
<BR>
<B>09h int CpuEnableIntr()</B><BR>
<BR>
<B>0Eh int CpuInvokeInKmode(void *function, ...)</B><BR>
<BR>
<B>0Fh void DisableDispatchIntr(int irq)</B><BR>
<BR>
<B>10h void EnableDispatchIntr(int irq)</B><BR>
<BR>
<B>11h int CpuSuspendIntr(int *state)</B><BR>
<BR>
<B>12h int CpuResumeIntr(int state)</B><BR>
<BR>
<B>17h int QueryIntrContext()</B><BR>
<BR>
<B>18h int QueryIntrStack(void *sp)</B><BR>
<BR>
<B>19h int iCatchMultiIntr(void)</B><BR>
<BR>
<BR>
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="biosiopssbusc"></A>&nbsp;
BIOS IOP SSBUSC - Subsystem Bus Controller
</FONT></TD></TR></TABLE><BR>
Not entirely sure what SSBUSC does. It seems to involve memory mapping and access times for the IOP?<BR>
<BR>
<B>Exports</B><BR>
<B>04h int SetDelay(int device, uint value)</B><BR>
<BR>
<B>05h int GetDelay(int device)</B><BR>
<BR>
<B>06h int SetBaseAddress(int device, uint value)</B><BR>
<BR>
<B>07h int GetBaseAddress(int device)</B><BR>
<BR>
<B>08h int SetRecoveryTime(uint value)</B><BR>
<BR>
<B>09h int GetRecoveryTime()</B><BR>
<BR>
<B>0Ah int SetHoldTime(uint value)</B><BR>
<BR>
<B>0Bh int GetHoldTime()</B><BR>
<BR>
<B>0Ch int SetFloatTime(uint value)</B><BR>
<BR>
<B>0Dh int GetFloatTime()</B><BR>
<BR>
<B>0Eh int SetStrobeTime(uint value)</B><BR>
<BR>
<B>0Fh int GetStrobeTime()</B><BR>
<BR>
<B>10h int SetCommonDelay(uint value)</B><BR>
<BR>
<B>11h int GetCommonDelay()</B><BR>
<BR>
<BR>
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="biosiopdmacman"></A>&nbsp;
BIOS IOP DMACMAN - DMA Manager
</FONT></TD></TR></TABLE><BR>
Note: The names below are made up, because no known modules expose symbols for DMACMAN.<BR>
<BR>
<B>Exports</B><BR>
<B>04h void DmaSetMadr(int chan, uint value)</B><BR>
<BR>
<B>05h uint DmaGetMadr(int chan)</B><BR>
<BR>
<B>06h void DmaSetBcr(int chan, uint value)</B><BR>
<BR>
<B>07h uint DmaGetBcr(int chan)</B><BR>
<BR>
<B>08h void DmaSetChcr(int chan, uint value)</B><BR>
<BR>
<B>09h uint DmaGetChcr(int chan)</B><BR>
<BR>
<B>0Ah void DmaSetTadr(int chan, uint value)</B><BR>
<BR>
<B>0Bh uint DmaGetTadr(int chan)</B><BR>
<BR>
<B>0Eh void DmaSetDpcr(uint value)</B><BR>
<BR>
<B>0Fh uint DmaGetDpcr()</B><BR>
<BR>
<B>10h void DmaSetDpcr2(uint value)</B><BR>
<BR>
<B>11h uint DmaGetDpcr2()</B><BR>
<BR>
<B>12h void DmaSetDpcr3(uint value)</B><BR>
<BR>
<B>13h uint DmaGetDpcr3()</B><BR>
<BR>
<B>14h void DmaSetDicr(uint value)</B><BR>
<BR>
<B>15h uint DmaGetDicr()</B><BR>
<BR>
<B>16h void DmaSetDicr2(uint value)</B><BR>
<BR>
<B>17h uint DmaGetDicr2()</B><BR>
<BR>
<B>1Ch int DmaRequestTransfer(uint chan, void* addr, uint size, uint count, int dir)</B><BR>
<BR>
<B>20h void DmaStartTransfer(uint chan)</B><BR>
<BR>
<B>21h void DmaSetChanPrio(uint chan, uint val)</B><BR>
<BR>
<B>22h void DmaEnableChan(uint chan)</B><BR>
<BR>
<B>23h void DmaDisableChan(uint chan)</B><BR>
<BR>
<BR>
</BODY></HTML>
