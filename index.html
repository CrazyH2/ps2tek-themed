<HTML><HEAD>
<TITLE>ps2tek - Documentation on PS2 internals</title>
</HEAD><BODY bgcolor="#FFFFFF" text="#000000" link="#0033cc" vlink="#0033cc" alink="#0033cc">
  <TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="contents"></A>&nbsp;
  Contents
</FONT></TD></TR></TABLE><BR>
  <A HREF="#memorymap">Memory Map</A><BR>
  <A HREF="#iomaps">I/O Maps</A><BR>
  <A HREF="#gif">Graphics Interface (GIF)</A><BR>
  <A HREF="#dmac">DMA Controller (DMAC)</A><BR>
  <A HREF="#eeintc">EE Interrupt Controller (INTC)</A><BR>
  <A HREF="#cdvd">CDVD Drive</A><BR>
  <A HREF="#iopint">IOP Interrupts</A><BR>
  <A HREF="#ioptimers">IOP Timers</A><BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="memorymap"></A>&nbsp;
Memory Map
</FONT></TD></TR></TABLE><BR>
<B>EE Virtual/Physical Memory Map</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  KUSEG: 00000000h-7FFFFFFFh User segment
  KSEG0: 80000000h-9FFFFFFFh Kernel segment 0
  KSEG1: A0000000h-BFFFFFFFh Kernel segment 1
  
  Virtual    Physical
  00000000h  00000000h  32 MB    Main RAM (first 1 MB reserved for kernel)
  20000000h  00000000h  32 MB    Main RAM, uncached
  30100000h  00100000h  31 MB    Main RAM, uncached and accelerated
  10000000h  10000000h  64 KB    I/O registers
  11000000h  11000000h  4 KB     VU0 code memory
  11004000h  11004000h  4 KB     VU0 data memory
  11008000h  11008000h  16 KB    VU1 code memory
  1100C000h  1100C000h  16 KB    VU1 data memory
  12000000h  12000000h  8 KB     GS privileged registers
  1C000000h  1C000000h  2 MB     IOP RAM
  1FC00000h  1FC00000h  4 MB     BIOS, uncached (rom0)
  9FC00000h  1FC00000h  4 MB     BIOS, cached (rom09)
  BFC00000h  1FC00000h  4 MB     BIOS, uncached (rom0b)
  70000000h  ---------  16 KB    Scratchpad RAM (only accessible via virtual addressing)
</TD></TR></TABLE>
EE RAM is reportedly expandable up to 256 MB.
However, the maximum seen in practice is 128 MB, for special TOOL consoles.<BR>
<BR>
<B>IOP Physical Memory Map</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  KUSEG: 00000000h-7FFFFFFFh User segment
  KSEG0: 80000000h-9FFFFFFFh Kernel segment 0
  KSEG1: A0000000h-BFFFFFFFh Kernel segment 1
  
  Physical
  00000000h  2 MB     Main RAM (same as on PSX)
  1D000000h           SIF registers
  1F800000h  64 KB    Various I/O registers
  1F900000h  1 KB     SPU2 registers
  1FC00000h  4 MB     BIOS (rom0) - Same as EE BIOS
  
  FFFE0000h (KSEG2)   Cache control
</TD></TR></TABLE><BR>
<B>Additional Memory</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4 MB   GS VRAM (used for framebuffer, textures, zbuffer, etc)
  2 MB   SPU2 work RAM - quadrupled from PSX's SPU
  8 MB   Memory card
</TD></TR></TABLE><BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="iomaps"></A>&nbsp;
I/O Maps
</FONT></TD></TR></TABLE><BR>
  
EE Map<BR>
<B>EE Timers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  100000xxh        Timer 0
  100008xxh        Timer 1
  100010xxh        Timer 2
  100018xxh        Timer 3
</TD></TR></TABLE>
<B>Image Processing Unit (IPU)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  10002000h 8h     IPU Command
  10002010h 4h     IPU Control
  10002020h 4h     IPU bit pointer control
  10002030h 8h     Top of bitstream
  10007000h 10h    Out FIFO (read)
  10007010h 10h    In FIFO (write)
</TD></TR></TABLE>
<B>Graphics Interface (GIF)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  10003000h 4h     GIF_CTRL - Control register
  10003010h 4h     GIF_MODE - Mode setting
  10003020h 4h     GIF_STAT - Status
  10003040h 4h     GIF_TAG0 - Bits 0-31 of tag before
  10003050h 4h     GIF_TAG1 - Bits 32-63 of tag before
  10003060h 4h     GIF_TAG2 - Bits 64-95 of tag before
  10003070h 4h     GIF_TAG3 - Bits 96-127 of tag before
  10003080h 4h     GIF_CNT - Transfer status counter
  10003090h 4h     GIF_P3CNT - PATH3 transfer status counter
  100030A0h 4h     GIF_P3TAG - Bits 0-31 of PATH3 tag when interrupted
  10006000h 10h    GIF FIFO
</TD></TR></TABLE>
<B>DMA Controller (DMAC)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  100080xxh        VIF0 - channel 0
  100090xxh        VIF1 - channel 1
  1000A0xxh        GIF - channel 2
  1000B0xxh        IPU_FROM - channel 3
  1000B4xxh        IPU_TO - channel 4
  1000C0xxh        SIF0 - channel 5
  1000C4xxh        SIF1 - channel 6
  1000C8xxh        SIF2 - channel 7
  1000D0xxh        SPR_FROM - channel 8
  1000D4xxh        SPR_TO - channel 9
  1000E000h 4h     D_CTRL - DMAC control
  1000E010h 4h     D_STAT - DMAC interrupt status
  1000E020h 4h     D_PCR - DMAC priority control
  1000E030h 4h     D_SQWC - DMAC skip quadword
  1000E040h 4h     D_RBSR - DMAC ringbuffer size
  1000E050h 4h     D_RBOR - DMAC ringbuffer offset
  1000E060h 4h     D_STADR - DMAC stall address
  1000F520h 4h     D_ENABLER - DMAC disabled status
  1000F590h 4h     D_ENABLEW - DMAC disable
</TD></TR></TABLE>
<B>Interrupt Controller (INTC)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1000F000h 4h     INTC_STAT - Interrupt status
  1000F010h 4h     INTC_MASK - Interrupt mask
</TD></TR></TABLE>
<B>Subsystem Interface (SIF)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1000F200h 4h     MSCOM - EE->IOP communication
  1000F210h 4h     SMCOM - IOP->EE communication
  1000F220h 4h     MSFLAG - EE->IOP flags
  1000F230h 4h     SMFLAG - IOP->EE flags
  1000F240h 4h     Control register
</TD></TR></TABLE>
<B>Privileged GS registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  12000000h 8h     PMODE - various PCRTC controls
  12000010h 8h     SMODE1
  12000020h 8h     SMODE2
  12000030h 8h     SRFSH
  12000040h 8h     SYNCH1
  12000050h 8h     SYNCH2
  12000060h 8h     SYNCV
  12000070h 8h     DISPFB1 - display buffer for output circuit 1
  12000080h 8h     DISPLAY1 - output circuit 1 control
  12000090h 8h     DISPFB2 - display buffer for output circuit 2
  120000A0h 8h     DISPLAY2 - output circuit 2 control
  120000B0h 8h     EXTBUF
  120000C0h 8h     EXTDATA
  120000D0h 8h     EXTWRITE
  120000E0h 8h     BGCOLOR - background color
  12001000h 8h     GS_CSR - control register
  12001010h 8h     GS_IMR - GS interrupt control
  12001040h 8h     BUSDIR - transfer direction
  12001080h 8h     SIGLBLID - signal
</TD></TR></TABLE><BR>
IOP Map<BR>
<B>Subsystem Interface (SIF)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1D000000h 4h     MSCOM - EE->IOP communication
  1D000010h 4h     SMCOM - IOP->EE communication
  1D000020h 4h     MSFLAG - EE->IOP flags
  1D000030h 4h     SMFLAG - IOP->EE flags
  1D000040h 4h     Control register
</TD></TR></TABLE>
<B>CDVD Drive</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1F402004h 1h     Current N command
  1F402005h 1h     N command status (R)
  1F402005h 1h     N command params (W)
  1F402006h 1h     Error
  1F402007h 1h     Send BREAK command
  1F402008h 1h     CDVD I_STAT - interrupt register
  1F40200Ah 1h     Drive status
  1F40200Fh 1h     Disk type
  1F402016h 1h     Current S command
  1F402017h 1h     S command status
  1F402018h 1h     S command params
</TD></TR></TABLE>
<B>Interrupt Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1F801070h 4h     I_STAT - Interrupt status
  1F801074h 4h     I_MASK - Interrupt mask
  1F801078h 1h     I_CTRL - Global interrupt disable
</TD></TR></TABLE>
<B>DMA registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1F80108xh        MDECin - channel 0
  1F80109xh        MDECout - channel 1
  1F8010Axh        SIF2 (GPU) - channel 2
  1F8010Bxh        CDVD - channel 3
  1F8010Cxh        SPU2 Core0 - channel 4
  1F8010Dxh        PIO - channel 5
  1F8010Exh        OTC - channel 6
  1F80150xh        SPU2 Core1 - channel 8
  1F80151xh        ??? - channel 9
  1F80152xh        SIF0 - channel 10
  1F80153xh        SIF1 - channel 11
  1F80154xh        SIO2in - channel 12
  1F80155xh        SIO2out - channel 13
  
  1F8010F0h 4h     DPCR - DMA priority control
  1F8010F4h 4h     DICR - DMA interrupt control
  1F801570h 4h     DPCR2 - DMA priority control 2
  1F801574h 4h     DICR2 - DMA priority control 2
</TD></TR></TABLE>
<B>IOP Timers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1F80110xh        Timer 0
  1F80111xh        Timer 1
  1F80112xh        Timer 2
  1F80148xh        Timer 3
  1F80149xh        Timer 4
  1F8014Axh        Timer 5
</TD></TR></TABLE>
<B>Serial Interface (SIO2)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1F808200h 40h    SEND3 buffer
  1F808240h 20h    SEND1/2 buffers
  1F808260h 1h     In FIFO
  1F808264h 1h     Out FIFO
  1F808268h 4h     SIO2 control
  1F80826Ch 4h     RECV1
  1F808270h 4h     RECV2
  1F808274h 4h     RECV3
</TD></TR></TABLE>
<B>Sound Processing Unit (SPU2)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1F900000h 180h   Core0 Voice 0-23 registers
  1F900190h 4h     Key ON 0/1
  1F900194h 4h     Key OFF 0/1
  1F90019Ah 2h     Core attributes
  1F90019Ch 4h     Interrupt address H/L
  1F9001A8h 4h     DMA transfer address H/L
  1F9001ACh 2h     Internal transfer FIFO
  1F9001B0h 2h     AutoDMA status
  1F9001C0h 120h   Core0 Voice 0-23 start/loop/next addresses
  1F900340h 4h     ENDX 0/1
  1F900344h 2h     Status register
  
  ... above addresses repeat for Core1 starting at 1F900400h ...
  
  1F900760h 2h     Master Volume Left
  1F900762h 2h     Master Volume Right
  1F900764h 2h     Effect Volume Left
  1F900766h 2h     Effect Volume Right
  1F900768h 2h     Core1 External Input Volume Left
  1F90076Ah 2h     Core1 External Input Volume Right
</TD></TR></TABLE><BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gif"></A>&nbsp;
Graphics Interface (GIF)
</FONT></TD></TR></TABLE><BR>
The GIF sends textures and geometry to the GS. It takes data from three different PATHs:<BR>
 - PATH1: VU1 via XGKICK instruction. Highest priority.<BR>
 - PATH2: VIF1 via DIRECT/DIRECTHL. Medium priority.<BR>
 - PATH3: GIF DMAC channel (channel 2). Lowest priority.<BR>
Only one PATH may run at a time.
Under normal conditions, when one PATH stops, the highest priority queued PATH will begin transfer.<BR>
<BR>
<B>GIF Reference</B><BR>
<A HREF="#gifio">GIF I/O</A><BR>
<A HREF="#giftags">GIFtags</A><BR>
<A HREF="#gifdataformats">GIF Data Formats</A><BR>
<A HREF="#gifpath3masking">GIF PATH3 Masking</A><BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gifio"></A>&nbsp;
GIF I/O
</FONT></TD></TR></TABLE><BR>
<B>10003000h GIF_CTRL - Control register (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Reset GIF
  1-2   Unused
  3     Temporary stop (1=stop transfers, 0=restart transfers)
  4-31  Unused
</TD></TR></TABLE><BR>
<B>10003010h GIF_MODE - Mode of operation (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Mask PATH3 (1=Mask)
  1     Unused
  2     Intermittent mode
</TD></TR></TABLE>
When PATH3 is masked by this register and GIF DMA is ongoing, the mask applies once GIF DMA ends its transfer.<BR>
<BR>
<B>10003020h GIF_STAT - Status register (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     PATH3 masked by GIF_MODE
  1     PATH3 masked by VIF1 MASKP3 register
  2     Intermittent mode activated
  3     Temporary stop 
  4     Unused
  5     PATH3 interrupted (by intermittent mode?)
  6     PATH3 queued
  7     PATH2 queued
  8     PATH1 queued
  9     Output path (1=transfer ongoing)
  10-11 Active path
        0=Idle
        1=PATH1
        2=PATH2
        3=PATH3
  12    Transfer direction (0=EE->GS, 1=GS->EE)
  13-23 Unused
  24-28 Data in GIF FIFO (in quadwords, max 16)
  29-31 Unused
</TD></TR></TABLE><BR>
<B>10003040h GIF_TAG0 (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Bits 0-31 of most recently read GIFtag
</TD></TR></TABLE>
<B>10003050h GIF_TAG1 (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Bits 32-63 of most recently read GIFtag
</TD></TR></TABLE>
<B>10003060h GIF_TAG2 (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Bits 64-95 of most recently read GIFtag
</TD></TR></TABLE>
<B>10003070h GIF_TAG3 (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Bits 96-127 of most recently read GIFtag
</TD></TR></TABLE>
These registers are only readable when the GIF has been paused by GIF_CTRL.<BR>
For details on the GIFtag format, see<BR>
<A HREF="#giftags">GIFtags</A><BR>
<BR>
<B>10003080h GIF_CNT (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-14  Backwards loop counter from NLOOP
        Decrements to zero
  15    Unused
  16-19 Register descriptor in progress
        0=highest
        1=lowest
        2=2nd lowest
        ...
        15=15th lowest
  20-29 VU data address being transferred
  30-31 Unused
</TD></TR></TABLE>
Only accessible when GIF is paused by GIF_CTRL.<BR>
<BR>
<B>10003090h GIF_P3CNT (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-14  Backwards loop counter from PATH3 NLOOP when PATH3 is interrupted
  15-31 Unused
</TD></TR></TABLE>
Only accessible when GIF is paused by GIF_CTRL.<BR>
<BR>
<B>100030A0h GIF_P3TAG (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Bits 0-31 of PATH3 GIFtag when PATH3 is interrupted
</TD></TR></TABLE>
Only accessible when GIF is paused by GIF_CTRL.<BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="giftags"></A>&nbsp;
GIFtags
</FONT></TD></TR></TABLE><BR>
The basic unit of GIF transfer data is the GIF packet.
Each packet is split into one or more primitives. Every primitive must be preceded by a GIFtag.<BR>
<BR>
<B>GIFtag Format</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-14    NLOOP - Data per register to transfer
  15      EOP - End of packet
  16-45   Unused
  46      Enable PRIM field
  47-57   Data to be sent to GS PRIM register if GIFtag.46 == 1
  58-59   Data format
          0=PACKED
          1=REGLIST
          2=IMAGE
          3=IMAGE
  60-63   NREGS - Number of registers
          0=16 registers
  64-127  Register field, 4 bits each
</TD></TR></TABLE><BR>
When NLOOP == 0, all fields are ignored except EOP and no further processing is done.<BR>
When GIFtag.46 == 0, an idle cycle is inserted before processing begins.<BR>
Registers are handled in little-endian order; i.e. bits 64-67 are processed first, then 68-71, and so on.<BR>
<BR>
NOTE: The GS Q register is initialized to 1.0f when reading a GIFtag.<BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gifdataformats"></A>&nbsp;
GIF Data Formats
</FONT></TD></TR></TABLE><BR>
The data format after a GIFtag varies depending on the value of GIFtag.58-59.
The GIF can transfer to the GS in PACKED, REGLIST, or IMAGE formats.<BR>
<BR>
<B>PACKED Format</B><BR>
Data is transferred in units of quadwords (16 bytes).
Total amount of data in the GIF primitive = NLOOP * NREGS.<BR>
All registers not specified below output the lower 64-bits of the quadword to their GS register directly.
The upper 64-bits are discarded.<BR>
<BR>
<B>Current reg=0h PRIM</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-10    Data to write to GS PRIM
  11-127  Unused
</TD></TR></TABLE><BR>
<B>Current reg=1h RGBA</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Writes to RGBAQ register (Q is unchanged)
  0-7     R
  8-31    Unused
  32-39   G
  40-63   Unused
  64-71   B
  72-95   Unused
  96-103  A
  104-127 Unused
</TD></TR></TABLE>
R, G, B, and A are 8-bit values. Q is set by the STQ command.<BR>
<BR>
<B>Current reg=2h STQ</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Writes to ST register and Q component of RGBAQ.
  0-31    S
  32-63   T
  64-95   Q
  96-127  Unused
</TD></TR></TABLE>
S, T, and Q are single-precision (32-bit) floats in IEEE 754 format.<BR>
<BR>
<B>Current reg=3h UV</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-13    U
  14-31   Unused
  32-45   V
  46-127  Unused
</TD></TR></TABLE>
U and V are 14-bit unsigned fixed-point integers with a 4-bit fractional component.<BR>
<BR>
<B>Current reg=4h XYZ2F/XYZ3F</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15    X
  16-31   Unused
  32-47   Y
  48-67   Unused
  68-91   Z
  92-99   Unused
  100-107 F
  108-110 Unused
  111     Disable drawing (1=write to XYZ3F, 0=write to XYZ2F)
  112-127 Unused
</TD></TR></TABLE>
X and Y are signed 16-bit fixed-point integers with a 4-bit fractional component.<BR>
Z is a 24-bit integer, and F is an 8-bit integer.<BR>
The "disable drawing" bit controls whether the data is written to XYZ2F or XYZ3F.<BR>
<BR>
<B>Current reg=5h XYZ2/XYZ3</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15    X
  16-31   Unused
  32-47   Y
  48-63   Unused
  64-95   Z
  96-110  Unused
  111     Disable drawing (1=write to XYZ3F, 0=write to XYZ2F)
  112-127 Unused
</TD></TR></TABLE>
Similar to XYZ2F/XYZ3F above, except there is no F register and Z is 32-bit.<BR>
<BR>
<B>Current reg=Ah FOG</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-99    Unused
  100-107 F
  108-127 Unused
</TD></TR></TABLE><BR>

<B>Current reg=Eh A+D (output data to specified address)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-63    Data
  64-71   Register address
  72-127  Unused
</TD></TR></TABLE>
Outputs data to the given register address.<BR>
<BR>
WARNING: Do not use this register descriptor on PATH3 when PATH1 is also running, or the GS may lock up!<BR>
<BR>
<B>Current reg=Fh NOP</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Data not output to GS.
</TD></TR></TABLE><BR>
  
<B>REGLIST Format</B><BR>
Total data in GIF primitive = NREGS * NLOOP, in units of doublewords. (64-bits)<BR>
In REGLIST, a doubleword is sent directly to the register descriptor.
Every quadword contains data for two registers.
When the data is prepared properly, this can multiply data density by up to a factor of 2.<BR>
When NREGS * NLOOP is odd, the last doubleword in a primitive is discarded.<BR>
<BR>
<B>IMAGE Format</B><BR>
Total data in GIF primitive = NLOOP only, in units of quadwords.<BR>
IMAGE is a shortcut for writing to the GS HWREG register, which transfers textures and other data to VRAM.
Each quadword has enough data for two writes to HWREG.<BR>
<BR>
<BR>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="gifpath3masking"></A>&nbsp;
GIF PATH3 Masking
</FONT></TD></TR></TABLE><BR>
PATH1 and PATH2 transfer to the GS without any internal buffering.
However, PATH3 has a 16-quadword GIF FIFO.<BR>
When PATH3 masking is enabled, data sent by PATH3 will reside in the FIFO until the mask is lifted.
This is useful for queueing texture transfers while other paths are sending geometry. 
GTA: San Andreas, Lemmings, and some other games rely on this.<BR>
<BR>
Furthermore, Wallace and Gromit at Project Zoo will enable the mask and start a GIF DMA transfer, expecting it to finish.
Emulating PATH3 masking without emulating the GIF FIFO will cause it to hang on a black screen,
as the DMA channel is unable to write any data.<BR>
<BR>
<BR>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="dmac"></A>&nbsp;
DMA Controller (DMAC)
</FONT></TD></TR></TABLE><BR>
The DMAC gives an interface for the EE to access the rest of the system.
It can transfer one quadword (16 bytes) at bus speed (half the rate of the EE's clock).<BR>
<BR>
<B>DMAC Reference</B><BR>
<A HREF="#dmacio">DMAC I/O</A><BR>
<A HREF="#dmacchainmode">DMAC Chain Mode</A><BR>
<A HREF="#dmacint">DMAC Interrupts</A><BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="dmacio"></A>&nbsp;
DMAC I/O
</FONT></TD></TR></TABLE><BR>
<B>Channels</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  100080xxh    VIF0
  100090xxh    VIF1 (can act as PATH2 for GIF)
  1000A0xxh    GIF (PATH3)
  1000B0xxh    IPU_FROM
  1000B4xxh    IPU_TO
  1000C0xxh    SIF0 (from IOP)
  1000C4xxh    SIF1 (to IOP)
  1000C8xxh    SIF2 (bidirectional, used for PSX mode and debugging)
  1000D0xxh    SPR_FROM
  1000D4xxh    SPR_TO
</TD></TR></TABLE><BR>
<B>1000xx00h Dn_CHCR - Channel control (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     DIR - Direction (0=to memory, 1=from memory)
        Only effective for VIF1 and SIF2
  1     Unused
  2-3   MOD - Mode (0=normal, 1=chain, 2=interleave)
  4-5   ASP - Address stack pointer
  6     TTE - Transfer DMAtag (only in source chain mode)
  7     TIE - Enable IRQ bit in DMAtag
  8     STR - Start/busy
  9-15  Unused
  16-31 TAG - Bits 16-31 of most recently read DMAtag
</TD></TR></TABLE><BR>

<B>1000xx10h Dn_MADR - Channel address (R/W)</B><BR>
<B>1000xx30h Dn_TADR - Channel tag address (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-30  Address (lower 4 bits must be zero)
  31    Memory selection (0=RAM, 1=scratchpad)
</TD></TR></TABLE>
The channel will read from/write to MADR directly during a transfer. TADR is only used for chain mode.<BR>
MADR and TADR update while a transfer is ongoing, i.e., the DMAC has no internal channels for memory addresses.<BR>
Certain games expect MADR and TADR to increment during a transfer.<BR>
<BR>
  
<B>1000xx20h Dn_QWC - Quadword count (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Quadwords
  16-31 Unused
</TD></TR></TABLE>
In normal and interleaved mode, the transfer ends when QWC reaches zero. Chain mode behaves differently; see<BR>
<A HREF="#dmacchainmode">DMAC Chain Mode</A><BR>
<BR>

<B>1000xx40h Dn_ASR0 - Channel saved tag address (R/W)</B><BR>
<B>1000xx50h Dn_ASR1 - Channel saved tag address (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-30  Tag address (lower 4 bits must be zero)
  31    Memory selection (0=RAM, 1=scratchpad)
</TD></TR></TABLE>
ASR0/ASR1 can only be used by the VIF0, VIF1, and GIF channels.<BR>
<BR>

<B>1000xx80h Dn_SADR - Channel scratchpad address (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-13  Address (lower 4 bits must be zero)
  14-31 Unused
</TD></TR></TABLE>
SADR is only used by SPR_FROM and SPR_TO.<BR>
<BR>
  
<B>1000E000h D_CTRL - DMAC control (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    DMA enable
  1    Cycle stealing on
  2-3  MFIFO drain channel
       0=None
       1=Reserved
       2=VIF1
       3=GIF
  4-5  Stall control channel
       0=None
       1=SIF0
       2=SPR_FROM
       3=IPU_FROM
  6-7  Stall control drain channel
       0=None
       1=VIF1
       2=GIF
       3=SIF1
  8-10 Release cycle period
       0=8
       1=16
       2=32
       3=64
       4=128
       5=256
</TD></TR></TABLE>
When cycle stealing is on, the release cycle period controls how long the EE has control of the bus.<BR>
<BR>
<B>1000E010h D_STAT - DMAC interrupt status (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-9    Channel interrupt status (1=IRQ, write 1 to clear)
  10-12  Unused
  13     DMA stall interrupt status
  14     MFIFO empty interrupt status
  15     BUSERR interrupt status
  16-25  Channel interrupt mask (1=enabled, write 1 to reverse)
  26-28  Unused
  29     Stall interrupt mask
  30     MFIFO empty mask
</TD></TR></TABLE>
INT1 is asserted when (status & mask) != 0.<BR>
<BR>
<B>1000E020h D_PCR - DMAC priority control (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-9    COP0 condition control
  10-15  Unused
  16-25  Channel priority (0=Channel disabled, only if D_PCR.31 is true)
  26-30  Unused
  31     Priority enable
</TD></TR></TABLE>
COP0 control determines whether or not CPCOND0 is activated.
If (~control | D_STAT.0-9) == 0x3FF, CPCOND0 is set.
This is useful for knowing when multiple DMA transfers have finished without using interrupts.<BR>
<BR>
<B>1000E030h D_SQWC - DMAC skip quadword (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   Quadwords to skip
  8-15  Unused
  16-23 Quadwords to transfer
  24-31 Unused
</TD></TR></TABLE>
In interleave mode, every time D_SQWC.16-23 quadwords have been transferred, D_SQWC.0-7 quadwords are skipped.<BR>
<BR>
<B>1000E040h D_RBSR - DMAC ringbuffer size (R/W)</B><BR>
<BR>
<B>1000E050h D_RBOR - DMAC ringbuffer offset (R/W)</B><BR>
<BR>
<B>1000F520h D_ENABLER - DMAC disabled status (R)</B><BR>
<B>1000F590h D_ENABLEW - DMAC disable (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  16    DMAC disabled
  All other bits appear to be garbage, but writable
  SCPH-39001 (and other BIOSes?) seems to expect D_ENABLER to be set to 1201h upon boot
</TD></TR></TABLE><BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="dmacchainmode"></A>&nbsp;
DMAC Chain Mode
</FONT></TD></TR></TABLE><BR>
The DMAC can intelligently chain DMA transfers together.
When a transfer starts in chain mode, the channel will transfer QWC quadwords and then read a DMAtag.<BR>
In source chain mode, the DMAtag comes from TADR.
In destination chain mode, the DMAtag comes from the peripheral the channel is reading from.<BR>
<BR>
<B>DMAtag</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15    QWC to transfer
  16-25   Unused
  26-27   Priority control
          0=No effect
          1=Reserved
          2=Priority control disabled (D_PCR.31 = 0)
          3=Priority control enabled (D_PCR.31 = 1)
  28-30   Tag ID
  31      IRQ
  32-62   ADDR field (lower 4 bits must be zero)
  63      Memory selection for ADDR (0=RAM, 1=scratchpad)
  64-127  Data to transfer (only if Dn_CHCR.TTE==1)
</TD></TR></TABLE>
When both IRQ and Dn_CHCR.TIE are set, the transfer ends after QWC has been transferred.<BR>
When Dn_CHCR.TTE is on, bits 64-127 are transferred BEFORE QWC.<BR>
The effects of the tag ID vary depending on if the channel is in source chain or dest chain mode.<BR>
<BR>
<B>Source Chain Tag ID</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    refe    MADR=DMAtag.ADDR
               TADR+=16
               tag_end=true
  
  1    cnt     MADR=TADR+16 (next to DMAtag)
               TADR=MADR (next to transfer data)
  
  2    next    MADR=TADR+16
               TADR=DMAtag.ADDR
  
  3    ref     MADR=DMAtag.ADDR
               TADR+=16
  
  4    refs    MADR=DMAtag.ADDR
               TADR+=16
  
  5    call    MADR=TADR+16
               if (CHCR.ASP == 0)
                 ASR0=MADR+(QWC*16)
               else if (CHCR.ASP == 1)
                 ASR1=MADR+(QWC*16)
               TADR=DMAtag.ADDR
               CHCR.ASP++
  
  6    ret     MADR=TADR+16
               if (CHCR.ASP == 2)
                 TADR=ASR1
                 CHCR.ASP--
               else if (CHCR.ASP == 1)
                 TADR=ASR0
                 CHCR.ASP--
               else
                 tag_end=true
  
  7    end     MADR=TADR+16
                 tag_end=true
               
</TD></TR></TABLE>
When tag_end=true, the transfer ends after QWC has been transferred.<BR>
<BR>
<B>Dest Chain Tag ID</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    cnt     MADR=DMAtag.ADDR
  
  1    cnts    MADR=DMAtag.ADDR
  
  7    end     MADR=DMAtag.ADDR
               tag_end=true
</TD></TR></TABLE><BR>
<B>DMA Resuming</B><BR>
If a transfer starts in source chain mode and QWC > 0,
the DMAC assumes that the TAG field of CHCR was the last read DMAtag.
This means that if the tag ID is REFE or END, the channel will stop after QWC has been transferred.<BR>
Sony's movie-playing library requires this behavior,
as it uses MADR to determine the current movie buffer position.<BR>
<BR>
<BR>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="dmacint"></A>&nbsp;
DMAC Interrupts
</FONT></TD></TR></TABLE><BR>
Upon any transfer completion, the DMAC will raise the channel's stat flag in D_STAT.
When (stat & mask) != 0, the DMAC asserts an INT1 signal to the EE.<BR>
INT1 may also be asserted when MFIFO is empty, a stall occurs, or a bus error occurs.
The bus error is non-maskable via D_STAT.<BR>
NOTE: INT0 (INTC) has priority over INT1.
If INT0 and INT1 are asserted at the same time, the INT0 interrupt will be processed first.<BR>
<BR>
<BR>
 
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="eeintc"></A>&nbsp;
EE Interrupt Controller (INTC)
</FONT></TD></TR></TABLE><BR>
The EE has two separate interrupt signals: INT0 (raised by INTC) and INT1 (raised by DMAC).<BR>
<BR>
<B>1000F000h INTC_STAT - Interrupt status register (R=Status, W=Acknowledge)</B><BR>
<B>1000F010h INTC_MASK - Interrupt mask register (R/W)</B><BR>
Status: Read INTC_STAT (1=IRQ raised)<BR>
Acknowledge: Write INTC_STAT (0=No effect 1=Clear bit)<BR>
Mask: Write INTC_MASK (0=No effect, 1=Reverse)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     IRQ0   GS interrupt
  1     IRQ1   SBUS
  2     IRQ2   VBLANK start
  3     IRQ3   VBLANK end
  4     IRQ4   VIF0
  5     IRQ5   VIF1
  6     IRQ6   VU0
  7     IRQ7   VU1
  8     IRQ8   IPU
  9     IRQ9   Timer 0
  10    IRQ10  Timer 1
  11    IRQ11  Timer 2
  12    IRQ12  Timer 3
  13    IRQ13  SFIFO
  14    IRQ14  VU0 Watchdog
</TD></TR></TABLE><BR>
When (INTC_STAT & INTC_MASK), INT0 is asserted on COP0.Cause:8.
When COP0.Status:8 is true, an interrupt occurs, and the EE jumps to 80000200h.<BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="cdvd"></A>&nbsp;
CDVD Drive
</FONT></TD></TR></TABLE><BR>
Using the CDVD drive, the PS2 has the ability to read CDROMs, single-layer DVDs, and dual-layer DVDs.
It also sports backwards compatibility with the PSX's CDROM drive in PSX mode.<BR>
<BR>
CDVD commands are either asynchronous (N commands) or synchronous (S commands).
Seeks and reads fall into the former category, and miscellaneous commands, such as RTC access, fall into the latter.<BR>
<BR>
<B>CDVD Reference</B><BR>
<A HREF="#cdvdioports">CDVD I/O Ports</A><BR>
<A HREF="#cdvdncommands">CDVD N Commands</A><BR>
<A HREF="#cdvdreadsandseeks">CDVD Reads and Seeks</A><BR>
<A HREF="#cdvdscommands">CDVD S Commands</A><BR>
<BR>
<BR>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="cdvdioports"></A>&nbsp;
CDVD I/O Ports
</FONT></TD></TR></TABLE><BR>
<B>1F402004h Current N command (R/W)</B><BR>
Write to this register to send an N command. For a list of N commands, see<BR>
<A HREF="#cdvdncommands">CDVD N Commands</A><BR>
<BR>
<B>1F402005h N command status (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Unused
  1-3   Ready?
  4-5   Unused
  6     Ready
  7     Unused
</TD></TR></TABLE>
This shows if the CDVD drive is ready to receive an N command.
When bit 6 (0x40) is on, an N command can be sent.
Oddly, bits 1-3, when set, also seem to indicate ready status?<BR>
<BR>
<B>1F402005h N command param (W)</B><BR>
Send parameters for an N command here. This must be done BEFORE the N command has been sent via 1F402004h.<BR>
<BR>

<B>1F402006h CDVD error (R)</B><BR>
Any non-zero value indicates an error? Unknown what kind of errors are possible and what their values are.<BR>
<BR>
<B>1F402007h BREAK</B><BR>
Writing any value to this register sends a BREAK command to the CDVD drive, stopping execution of the current N command.<BR>
<BR>
<B>1F402008h CDVD I_STAT (R=Status, W=Acknowledge)</B><BR>
Status = Read I_STAT (1=Reason for IRQ)<BR>
Acknowledge = Write I_STAT (1=Clear bit)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Data ready?
  1     (N?) Command complete
  2     Power off pressed
  3     Disk ejected
  4     BS_Power DET?
  5-7   Unused
</TD></TR></TABLE>
When a CDVD IRQ is raised on I_STAT, this register shows the reason for the interrupt.
Bit 0 seems to be raised when a read command completes, but I'm not certain about this...<BR>
Unknown if bit 1 only applies to N commands, although this appears to be the case.<BR>
<BR>
<B>1F40200Ah CDVD drive status (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h  Stopped
  02h  Spinning
  06h  Reading
  0Ah  Paused
</TD></TR></TABLE>
<BR>
<B>1F40200Fh CDVD disk type (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h  None?
  12h  CDROM
  14h  DVD
  Unknown what other types are possible.
</TD></TR></TABLE>
<B>1F402016h Current S command (R/W)</B><BR>
Write to this register to send an S command. For a list of S commands, see<BR>
<A HREF="#cdvdscommands">CDVD S Commands</A><BR>
<BR>
<B>1F402017h S command status (R)</B><BR>
40h indicates that the CDVD drive can receive an S command. 00h means that it is busy.<BR>
<BR>
<B>1F402018h S command result (R)</B><BR>
When an S command has finished executing, read the result here. Some S commands may require multiple reads.<BR>
<BR>
<B>1F402018h S command params (W)</B><BR>
Parameters must be sent BEFORE the S command is sent.<BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="cdvdncommands"></A>&nbsp;
CDVD N Commands
</FONT></TD></TR></TABLE><BR>
Parameters are in units of bytes and are little-endian. All N commands raise IRQ2 (bit 1 of CDVD I_STAT).<BR><BR>
<B>00h NOP</B><BR>
<B>01h NOPsync</B><BR>
Params: None.<BR>
These commands do nothing? They do raise an IRQ upon their "completion".<BR>
<BR>
<B>02h Standby</B><BR>
Params: None.<BR>
Returns the read position to sector 0 and sets the drive status to PAUSED.<BR>
Possibly also spins the drive if it's not spinning already?<BR>
<BR>
<B>03h Stop</B><BR>
Params: None.<BR>
Returns the read position to sector 0, sets the drive status to STOPPED, and stops the drive from spinning.<BR>
Seems to have a 166 ms delay?<BR>
<BR>
<B>04h Pause</B><BR>
Params: None.<BR>
Unknown what effect this has, from the perspective of emulation.<BR>
<BR>
<B>05h Seek</B><BR>
Params:
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   Sector position
</TD></TR></TABLE>
Moves the read position to the indicated parameter.<BR>
<BR>
<B>06h ReadCd</B><BR>
Params:
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   Sector position
  4-7   Sectors to read
  10    Block size (1=2328 bytes, 2=2340 bytes, all others=2048 bytes)
</TD></TR></TABLE>
Performs a CD-style read. Seems to raise bit 0 of CDVD I_STAT upon completion?<BR>
<BR>
<B>08h ReadDvd</B><BR>
Params:
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   Sector position
  4-7   Sectors to read
</TD></TR></TABLE>
Performs a DVD-style read, with a block size of 2064 bytes. The format of the data is as follows:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    1    Volume number + 0x20
  1    3    Sector number - volume start + 0x30000, in big-endian.
  4    8    ? (all zeroes)
  12   2048 Raw sector data
  2060 4    ? (all zeroes)
</TD></TR></TABLE><BR>

<B>09h GetToc</B><BR>
Params: None?
Fetches the ToC from the disk, with a block size of 2064 bytes.<BR>
<BR>
<BR>
  
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="cdvdreadsandseeks"></A>&nbsp;
CDVD Reads and Seeks
</FONT></TD></TR></TABLE><BR>
<B>Seeking</B><BR>
If a read command is called, a seek must be performed.
An IRQ is NOT raised when the seek finishes during a read command.<BR>
When a seek begins, if the drive is currently not spinning, it takes 333 ms for the drive to spin and finish the seek.<BR>
Otherwise, one of three seek modes is possible:<BR>
- Contiguous read: When the seek delta is very small or zero, seek time = block_timing * delta<BR>
- Fast seek: When seek delta < 14764 for DVD reads and < 4371 for CD reads, seek time = ~30 ms<BR>
- Full seek: Seek time = ~100 ms<BR>
block_timing (in IOP cycles) can be found by the following formula:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  block_timing = (IOP_CLOCK * block_size) / read_speed
</TD></TR></TABLE>
Where IOP_CLOCK is ~36,864,000 Hz.
read_speed for CD reads is 24 * 153600. For DVD reads read_speed = 4 * 1382400.<BR>
Unknown what delta is needed for a contiguous read (8/16 is used for CD/DVD respectively in PCSX2).<BR>
<BR>
<B>Reads</B><BR>
The time needed to read a single sector is the block_timing formula above.
Once one sector has been read, the CDVD DMA channel can store the data in memory
and allow the CDVD drive to continue.<BR>
When all sectors have been read, a CDVD IRQ is raised. Successful reads seem to raise both bits 1 AND 0 of CDVD I_STAT?<BR>
<BR>
<BR>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="cdvdscommands"></A>&nbsp;
CDVD S Commands
</FONT></TD></TR></TABLE><BR>
The results of an S command can be read one at a time from 1F402017. All units are in bytes.<BR>
<BR>
<B>08h ReadRTC</B><BR>
Params: None.
Result:
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Zero
  1     Second
  2     Minute
  3     Hour
  4     Zero
  5     Day
  6     Month
  7     Year
</TD></TR></TABLE>
Returns the current time stored on the RTC, in BCD format.<BR>
The RTC is mostly just used by the BIOS.
Notably, Metal Gear Solid 3 requires the RTC to boot. This is likely an anti-piracy feature.<BR>
<BR>
<B>09h WriteRTC</B><BR>
Params:
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Ignored
  1     Second
  2     Minute
  3     Hour
  4     Ignored
  5     Day
  6     Month
  7     Year
</TD></TR></TABLE>
Overwrites the RTC's time in BCD format.<BR>
<BR>

<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="iopint"></A>&nbsp;
IOP Interrupts
</FONT></TD></TR></TABLE><BR>
Interrupt handling for the IOP is similar to its PSX counterpart.
The main differences are an additional register (I_CTRL) and more interrupt lines.<BR>
<BR>
<B>1F801070h I_STAT - Interrupt status register (R=Status, W=Acknowledge)</B><BR>
<B>1F801074h I_MASK - Interrupt mask register (R/W)</B><BR>
Status: Read I_STAT (1=IRQ raised)<BR>
Acknowledge: Write I_STAT (0=Clear bit 1=No effect)<BR>
Mask: Read/Write I_MASK (0=Disabled 1=Enabled)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     IRQ0   VBLANK start
  1     IRQ1   GPU (used in PSX mode)
  2     IRQ2   CDVD Drive
  3     IRQ3   DMA
  4     IRQ4   Timer 0
  5     IRQ5   Timer 1
  6     IRQ6   Timer 2
  7     IRQ7   SIO0
  8     IRQ8   SIO1
  9     IRQ9   SPU2
  10    IRQ10  PIO
  11    IRQ11  VBLANK end
  12    IRQ12  DVD? (unknown purpose)
  13    IRQ13  PCMCIA (related to DEV9 expansion slot)
  14    IRQ14  Timer 3
  15    IRQ15  Timer 4
  16    IRQ16  Timer 5
  17    IRQ17  SIO2
  18    IRQ18  HTR0? (unknown purpose)
  19    IRQ19  HTR1?
  20    IRQ20  HTR2?
  21    IRQ21  HTR3?
  22    IRQ22  USB
  23    IRQ23  EXTR? (unknown purpose)
  24    IRQ24  FWRE (related to FireWire)
  25    IRQ25  FDMA? (FireWire DMA?)
  26-31 Unused/garbage
</TD></TR></TABLE><BR>
<B>1F801078h I_CTRL - Global interrupt control (R=Status and Disable, W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Disable all interrupts
  1-31  Unused/garbage
</TD></TR></TABLE>
When bit 0=1, all IOP interrupts are disabled. Reading this register returns bit 0 AND clears it, re-enabling interrupts. Writing can set or reset bit 0.<br>
NOTE: There seems to be a 4 cycle delay when re-enabling interrupts via this register.<BR>
<BR>
<B>Raising Interrupts</B><BR>
If I_CTRL && (I_STAT & I_MASK), then COP0.Cause:8 is set. When COP0.Status:8 is also set when this occurs,
COP0.Cause.Excode is set to 00h and the IOP jumps to 80000080h, where the interrupt will be processed.<BR>
<BR>
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
<A NAME="ioptimers"></A>&nbsp;
IOP Timers
</FONT></TD></TR></TABLE><BR>
<B>1F801100h+N*10h Timer 0..2 count (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Current value
  16-31 Unused/garbage
</TD></TR></TABLE>
<B>1F801480h+(N-3)*10h Timer 3..5 count (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Current value
</TD></TR></TABLE>
Timers 0..5 increment automatically. 0..2 are 16-bit, and 3..5 are 32-bit.
Writes set the counter to the value written.<BR>
<BR>
<B>1F801104h+N*10h Timer 0..2 mode (R/W)</B><BR>
<B>1F801484h+(N-3)*10h Timer 3..5 mode (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Gate enable
  1-2   Gate mode
  3     Zero return - reset counter on interrupt
  4     Compare interrupt enabled
  5     Overflow interrupt enabled
  6     Repeat/no effect?
  7     LEVL - toggle bit 10 on IRQs
        If not set, bit 10 is set to 0 on IRQ
  8     Use external signal
        If set:
          Timer 0: pixel clock (13.5 MHz regardless of screen mode)
          Timer 1/3: HBLANK
          Others: sysclock (no effect)
  9     Timer 2 prescaler
  10    Interrupts enabled (R)
  11    Compare interrupt raised (R)
  12    Overflow interrupt raised (R)
  13-14 Timer 4/5 prescalar
  15-31 Unused/garbage
</TD></TR></TABLE>
Writes to mode reset the count to zero and set bit 10 to 1.
Reads from mode clear the two raised interrupt flags.<BR>
Prescalers adjust clockrate as follows:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     normal
  1     1/8 speed
  2     1/16 speed
  3     1/256 speed
</TD></TR></TABLE><BR>
<B>1F801108h+N*10h Timer 0..2 target (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Value
  16-31 Unused/garbage
</TD></TR></TABLE>
<B>1F801488h+(N-3)*10h Timer 3..5 target (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Value
</TD></TR></TABLE>
When count == target, a compare interrupt is raised.
This raises an IRQ in I_STAT if both mode.4 and mode.10 are enabled.<BR>
If mode.7 (LEVL) is not set, writes to target set mode.10 to 1.<BR>
<BR>
<BR>
</BODY></HTML>
